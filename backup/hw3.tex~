% Search for all the places that say "PUT SOMETHING HERE".

\documentclass[11pt]{article}
\usepackage{amsmath,textcomp,amssymb,geometry,graphicx}

\def\Name{Alexander Chu}  % Your name
\def\Sec{107, Yun Park}  % Your GSI's name and discussion section
\def\Login{cs170-ix} % Your login
\def\Homework{3}%Number of Homework, PUT SOMETHING HERE
\def\Session{Fall 2013}


\title{CS170--Fall 2013 --- Solutions to Homework 2}
\author{\Name, section \Sec, \texttt{\Login}}
\markboth{CS170--\Session\  Homework \Homework\ \Name, section \Sec}{CS170--\Session\ Homework \Homework\ \Name, section \Sec, \texttt{\Login}}
\pagestyle{myheadings}

\begin{document}
\maketitle

\section*{Problem 1}
\subsection*{Part (a)}
$\log_3{2}>d=0 \Rightarrow \boxed{\theta(n^{\log_3{2}})}$
\subsection*{Part (b)}
$\log_4{5}>d=1 \Rightarrow \boxed{\theta(n^{\log_4{5}})}$
\subsection*{Part (c)}
$\log_7{7}=d=1 \Rightarrow \boxed{\theta(n\log_7{n})}$
\subsection*{Part (d)}
$\log_3{9}=2>d=2 \Rightarrow \boxed{\theta(n^{2}\log_3{n})}$
\subsection*{Part (e)}
$\log_2{8}=d=3 \Rightarrow \boxed{\theta(n^3\log{n})}$
\label{pg:end-of-p1}




% Make sure that the solution here does not exceed one page here. If
% it does, use the extra space for this problem at the end.  
%
% Comment out the next line if you are NOT using the extra space
\paragraph{} \emph{Continued on Page \pageref{pg:p1-continuation}}
\newpage


%%Do NOT remove/comment the next line
\pagestyle{plain}
%%It makes sure your name appears only on the first page
\section*{Problem 2}
\subsection*{Part (a)}
\begin{verbatim}
def find_majority_element(A):
    if len(A)==1:
        return A[0]
    A1, A2 = randomly_split_in_half(A)
    elem1 = find_majority_element(A1)
    elem2 = find_majority_element(A2)
    if elem1==elem2:
        return elem1
    else:
        num1=0
        num2=0
        for i in A:
            if i==elem1:
                num1+=1
            elif i==elem2:
                num2+=1
        if num1>ceil(len(A)/2):
            return elem1
        elif num2>ceil(len(A)/2):
            return elem2
        else:
            return None
\end{verbatim}
\label{pg:end-of-p2}

%Insert solution here

% Make sure that the solution here does not exceed one page here. If
% it does, use the extra space for this problem at the end.  
%
% Comment out the next line if you are NOT using the extra space
\paragraph{} \emph{Continued on Page \pageref{pg:p2-continuation}}



\newpage

\section*{Problem 3}

\subsection*{Part (a)}
\textbf{Lemma:} If four points are in a square of side length d, where d is the minimum distance between two points in the set of points, the points must lie on the corners of the square.\\
\textbf{Proof:} If d is the minimum distance between 2 points, then for each point P in the set S of 4 points, the circle of radius d about P must not contain other points. 
In other words, all other points must lie outside or on the edge of the circle of radius d centered at P for P in S.
The edge length of the square is d. The only way to fit all four points on the square without the circles of radius d containing other points is to place each point on a separate corner.
Now suppose for contradiction that a fifth point, Q could be contained in the square. Construct a circle of radius d about Q.
The circle now contains the four points already on the corners of the square.
The circle centered about Q through one of the other points on a square now has a radius less than d.
But d is defined as the smallest distance between any two points in the set of all points.
Contradiction reached.
\subsection*{Part (b)}
\textbf{Base Case:} \\
The algorithm can return 2 points when those are the only two points in the set. \\
\textbf{Inductive Hypothesis:}\\
The algorithm can find the closest two points of n points.\\
\textbf{Inductive Step:}\\
We now prove that the algorithm can find the closest two points in a set of size 2n.
By our inductive hypothesis, we can already compute the minimum distances dL and dR of the left and right partitions, respectively.
We now justify the algorithm for the center case.
According to the algorithm, we consider only the points in the set that are a distance min(dR,dL) from the center.
We then sort the remaining points by y coordinate compare each point with the 7 proceeding points.
As we have shown in part A, there can be at most 4 points in any square of side length d, where d is the minimal distance.
Consider some point P in the middle region. Suppose that there exists some point across the centerline with distance to P $d < min(dL,dR)$.
P must lie in either the square region across the centerline from P above P's y position, or the square region across from P below P's y position.
These two squares overlap in two of their corners. As shown in A, this amounts to a total of 6 points that must be compared with A.
Since we compare 7 points ahead each point, the farthest of these 6 points will be compared with P in the worst case. 
Likewise, P itself will be compared with the point 6 positions ahead in the sorted y list.
Hence, all the necessary comparisons will take place, and $d<min(dR,dL)$ will be computed if it, indeed, exists.
By induction on $\log(n)$, the algorithm successfully computes d $\forall n$.
\label{pg:end-of-p3}

% Make sure that the solution here does not exceed one page here. If
% it does, use the extra space for this problem at the end.  
%
% Comment out the next line if you are NOT using the extra space
\paragraph{} \emph{Continued on Page \pageref{pg:p3-continuation}}




\newpage

\section*{Problem 4}
\subsection*{Part (a)}
$e^{\frac{2\pi}{8}}=e^{\frac{\pi}{4}}$\\
$e^{\frac{\pi}{4}}+(e^{\frac{\pi}{4}})^7=e^{\frac{\pi}{4}}+e^{\frac{7\pi}{4}}=e^{\frac{\pi}{4}}+e^{-\frac{\pi}{4}}=2\cos(\frac{\pi}{4})=\boxed{\sqrt{2}}$
\subsection*{Part (b)}
$P(1)=\boxed{2}$\\
$P(e^{i\frac{\pi}{4}})=e^{i\frac{\pi}{2}}+1=\boxed{i+1}$\\
$P((e^{i\frac{\pi}{4}})^2)=e^{i\pi}+1=\boxed{0}$\\
$P((e^{i\frac{\pi}{4}})^3)=e^{i\frac{3\pi}{4}}+1=\boxed{1-i}$
\subsection*{Part (c)}
$q(\omega)=A\omega^3+B\omega^2+C\omega+D$
$3=A+B+C+D$
$1+i\sqrt{2}=(-\frac{\sqrt{2}}{2}+\frac{\sqrt{2}}{2}i)A+iB+(\frac{\sqrt{2}}{2}+\frac{\sqrt{2}}{2}i)C+D$
$1=-iA-B+iC+D$
$1+i\sqrt{2}=(\frac{\sqrt{2}}{2}+\frac{\sqrt{2}}{2}i)A-iB+(-\frac{\sqrt{2}}{2}+\frac{\sqrt{2}}{2}i)C+D$

Solving with Wolfram Alpha $\cdots$
$A=1$
$B=0$
$C=1$
$D=1$

$\boxed{q(\omega)=\omega^3+\omega+1}$

\label{pg:end-of-p4}

% Make sure that the solution here does not exceed one page here. If
% it does, use the extra space for this problem at the end.  
%
% Comment out the next line if you are NOT using the extra space
%\paragraph{} \emph{Continued on Page \pageref{pg:p4-continuation}}


\newpage

\section*{Problem 5}
\begin{verbatim}
def findMissing(nums):
    if len(nums)==1:
        return 0 if (nums[0] & 1!=0) else 1
    expectedZeroes=len(nums)//2+1
    zeroList=[]
    oneList=[]
    for i in nums:
        if (i & 1)==0:
            zeroList.append(i >> 1)
        else:
            oneList.append(i >> 1)
    if len(zeroList)<expectedZeroes:
        return findMissing(zeroList)<<1
    else:
        return (findMissing(oneList)<<1)|1
\end{verbatim}

We look at bit i, of all the numbers in the list, and see if the numbers of zeroes is floor(n/2). 
If so, the missing number has a 0 in bit i. Otherwise, it has a 1. 
Discard the half of the list that has the proper number of members.
Repeat until all integers in the list have been exhausted, and the missing number is known.

Space used: $\sum_{k=0}^{\log{n}} \frac{n}{2^n}=n\log{n}$
Time used: $T(n)=T(\frac{n}{2})+n=O(n)$

The total runtime is T(n/2)
\label{pg:end-of-p5}

%Insert solution here


% Make sure that the solution here does not exceed one page here. If
% it does, use the extra space for this problem at the end.  
%
% Comment out the next line if you are NOT using the extra space
%\paragraph{} \emph{Continued on Page \pageref{pg:p5-continuation}}


\newpage


\section*{Problem 6}

\begin{verbatim}
def findParetoPts(pts):
    if len(pts)<=1:
        return pts
    pts=sort_by_x(pts)
    leftPts=findParetoPts(pts[:floor(len(pts)/2)])
    rightPts=findParetoPts(pts[floor(len(pts)/2):])
    rightMax=get_maximum_y(rightPts)
    out = rightPts
    for pt in leftPts:
        if pt.y > rightMax:
        out.append(pt)
    return out
\end{verbatim}

The algorithm makes 2 recursive calls of problem size $\frac{n}{2}$, and executes $O(n\log(n))$ operations due to the sorting algorithm.
The runtime, thus, is parameterized as $T(n)=2T(\frac{n}{2})+n\log{n}=\boxed{n\log^2(n)}$

\label{pg:end-of-p6}

% Make sure that the solution here does not exceed one page here. If
% it does, use the extra space for this problem at the end.  
%
% Comment out the next line if you are NOT using the extra space
%\paragraph{} \emph{Continued on Page \pageref{pg:p6-continuation}}


\newpage


%% Comment out the "extra spaces" completely for the problems for you
%% don't need them

\section*{Extra space for Problem 1}
\emph{Continued from Page \pageref{pg:end-of-p1}}\\
\label{pg:p1-continuation}

\subsection*{Part (f)}
$\log_{25}{n}$ levels\\
At level k, the number of operations is $49^k(\frac{n}{25^k})^{\frac{3}{2}}\log{\frac{n}{25^k}}=(\frac{49}{125})^k n^{\frac{3}{2}}\log{\frac{n}{25^k}}$\\
Total number of operations: $\sum_{k=0}^{\log_{25}{n}}(\frac{49}{125})^k n^{\frac{3}{2}}\log{\frac{n}{25^k}}$\\
To find the lower bound, we find the first term: $\Omega(n^{\frac{3}{2}}\log{n})$\\
To find the upper bound, we do some comparisons: \\
$\sum_{k=0}^{\log_{25}{n}}(\frac{49}{125})^k n^{\frac{3}{2}}\log{\frac{n}{25^k}}$
$> \sum_{k=0}^{\log_{25}{n}}(\frac{49}{125})^k n^{\frac{3}{2}}\log{n}$
$> \sum_{k=0}^{\infty}(\frac{49}{125})^k n^{\frac{3}{2}}\log{n}$\\
$= n^{\frac{3}{2}}\log{n} \sum_{k=0}^{\infty} (\frac{49}{125})^k $
$= n^{\frac{3}{2}}\log{n} \frac{1}{1-\frac{49}{125}} $
$= O(n^{\frac{3}{2}}\log{n}) $\\
$T(n)=O(n^{\frac{3}{2}}\log{n}) \and T(n)=\Omega(n^{\frac{3}{2}}\log{n}) \Rightarrow \boxed{T(n)=\theta(n^{\frac{3}{2}}\log{n})}$
\subsection*{Part (g)}
Depth=$n$\\
Operations per step=$2$\\
Total operations=$2n=\boxed{\theta(n)}$
\subsection*{Part (h)}
Depth=$n$\\
Operations at level $k=(n-k)^c$\\
Total operations=$\sum_{k=0}^{n}(n-k)^c=\sum_{k=0}^{n}(k)^c=\boxed{\theta(n^{c+1})}$
\subsection*{Part (i)}
Depth=$n$\\
Operations at level $k=c^(n-k)$\\
Total operations=$\sum_{k=0}^{n}c^{n-k}=\sum_{k=0}^{n} c^{k}=\frac{1-c^{n+1}}{1-c}=\boxed{\theta(c^n)}$\\
\subsection*{Part (j)}
Depth=$n$\\
Operations at level $k=2^k$\\
Total operations=$\sum_{k=0}^n 2^k=\frac{1-2^{n+1}}{1-2}=2^{n+1}-1=\boxed{\theta(2^{n})}$
\subsection*{Part (k)}
$n^{\frac{1}{2^k}}=c$\\
$\log_c(n^{\frac{1}{2^k}})=\log_c{c}=1$\\
$\frac{1}{2^k}\log_c(n)=\log_c{c}=1$\\
$\log_c(n)=2^k$\\
$\log(\log_c(n))=k$\\
$\log(\frac{\log(n)}{\log{c}})=k$\\
$\log(\log(n))-\log(\log{c})=k$\\
$\sum_{i=0}^{\log(\log(n))}1=\boxed{\theta(\log(\log(n)))}$


\newpage
%%Comment out the above three lines if you are not using extra space
%%for this problem.


\section*{Extra space for Problem 2}
\emph{Continued from Page \pageref{pg:end-of-p2}}\\
\label{pg:p2-continuation}

\subsection*{Part (b)}
\textbf{Algorithm:}\\
\begin{verbatim}
def find_majority_element(A):
    def helper(A):
        if len(A)==2:
            if A[0]==A[1]:
                return [A[0]]
            else:
                return []
        elif len(A)==1:
            return [A[0]];
        A1,A2=splitList(A,helper(floor(len(A/2)))
        S = helper(A1) + helper(A2)
        if len(S)==1:
            return [S[0]]
        else:
            if len(S)==0 or S[0]!=S[1]:
                return []
            else:
                return S[0]
    out = helper(A)
    if len(out)==0:
        return None
    count=0;
    for i in A:
        if i==out[0]:
            count+=1
        else:
            count-=1
    return out[0] if count>0 else None
\end{verbatim}

\textbf{Proof:}\\
Helper uses recursion to pair elements arbitrarily with each other. 
If the elements match, one survives. 
If the elements do not match, they anihilate.
By definition, a majority of element A exists if and only if there is at least one or more A than every other element in the set.
Hence, Helper will return A if there is a majority of A in the list.
The recurrance relation of Helper is $T(n)=2T(n/2)+1=\theta(\log(n))$
However, $A\Rightarrow B \neq B \Rightarrow A$. There is a possibility that Helper will return an element when no majority exists.
Take, for example, the list [A,A,A,A,A,B,B,B,B,B,C,C,C,C,D,D,D,D,D,D]. Helper will return [D], even though there is no majority.
Hence, we run a check; We count the number of the element returned by Helper, and see if it comprises more than half of the list in $\theta(n)$ time.
If the count is less than n/2, then the algorithm will return no majority. Otherwise, it returns the potential majority from helper.


\newpage
%%Comment out the above three lines if you are not using extra space
%%for this problem.


\section*{Extra space for Problem 3}
\emph{Continued from Page \pageref{pg:end-of-p3}}\\
\label{pg:p3-continuation}

\subsection*{Part (c)}
\begin{verbatim}
def closestPoints(points):

    if len(points)==2:
        return (points[0],points[1]) 

    points = sort_on_x(points)
    median_index = find_median_index(points)
    median = points[median_index]

    leftPts=points[:median_index]
    pL,qL=closestPoints(leftPts)
    dL=getDistance(pL,qL)

    rightPts=points[median_index:]
    pR,qR=closestPoints(rightPts)
    dR=getDistance(pR,qR)

    d=min(dL,dR)

    dM=d

    middlePts = sort_on_y([i for i in points if abs(i.x-median.x)<d])

    for i in range(len(middlePts)):
        for j in range(1,8):
            if getDistance(middlePts[i],middlePts[j])<dM
                dM=getDistance(middlePts[i],middlePts[j])
                pM, qM = middlePts[i], middlePts[j]
    
    d=min(dL,dR,dM)
    if d==dL:
        return (pL,qL)
    if d==dR:
        return (pR,qR)
    if d==dM:
        return (pM,qM)
\end{verbatim}
The program has a branching factor of 2, and halves the problem size every time. 
Each recursive call sorts two lists, with a total overhead of $2n\log(n)=\theta(\log(n))$.
This yields a recurrance relation of $\boxed{T(n)=2T(\frac{n}{2})+n\log(n)}$\\
Tree depth: $\log{n}$\\
Branching factor: $2$\\
Operations at level $k=(2^k)\frac{n}{2^k}\log(\frac{n}{2^k})=n\log(\frac{n}{2^k})$\\
$\sum_{k=0}^{\log{n}} n\log(\frac{n}{2^k}) < \sum_{k=0}^{\log{n}} n\log(n)=n\log(n)\sum_{k=0}^{\log{n}} 1=\boxed{n(\log(n))^2}$
\subsection*{Part (d)}
Yes. Instead of sorting by y on every iteration, pass a single, pre-sorted y list and x list between calls. Pop elements from lists as needed.
This reduces the recurrance to $T(n)=2T(\frac{n}{2})+n=\theta(n\log(n))$.
\begin{verbatim}
def closestPoints(points):
    def helper(points,ySorted):
    
        if len(points)==2:
            return (points[0],points[1]) 
    
        median_index = find_median_index(points)
        median = points[median_index]
    
        leftPts=points[:median_index]
        leftYSorted = [i for i in ySorted if i.x < median.x]
        pL,qL=closestPoints(leftPts,leftYSorted)
        dL=getDistance(pL,qL)
    
        rightPts=points[median_index:]
        rightYSorted = [i for i in ySorted if i.x >= median.x]
        pR,qR=closestPoints(rightPts,rightYSorted)
        dR=getDistance(pR,qR)
    
        d=min(dL,dR)
    
        dM=d
    
        middlePts = [i for i in ySorted if abs(i.x-median.x)<d] #Preserves sorted order.
    
        for i in range(len(middlePts)):
            for j in range(1,8):
                if getDistance(middlePts[i],middlePts[j])<dM
                    dM=getDistance(middlePts[i],middlePts[j])
                    pM, qM = middlePts[i], middlePts[j]
        
        d=min(dL,dR,dM)
        if d==dL:
            return (pL,qL)
        if d==dR:
            return (pR,qR)
        if d==dM:
            return (pM,qM)
    xSorted=sort_on_x(points)
    ySorted=sort_on_y(points)
    return helper(xSorted,ySorted)
\end{verbatim}


\newpage
%%Comment out the above three lines if you are not using extra space
%%for this problem.



\section*{Extra space for Problem 4}
\emph{Continued from Page \pageref{pg:end-of-p4}}\\

%Insert solution here

\label{pg:p4-continuation}
\newpage
%%Comment out the above three lines if you are not using extra space
%%for this problem.



\section*{Extra space for Problem 5}
\emph{Continued from Page \pageref{pg:end-of-p5}}\\

%Insert solution here


\label{pg:p5-continuation}
\newpage
%%Comment out the above three lines if you are not using extra space
%%for this problem.


\section*{Extra space for Problem 6}
\emph{Continued from Page \pageref{pg:end-of-p6}}\\


%Insert solution here


\label{pg:p6-continuation}
\newpage
%%Comment out the above three lines if you are not using extra space
%%for this problem.



\end{document}
