Expectation
===========
  x() flips a coin.
  heads: 1 second to execute
  tails: 3 seconds to execute

  Let X be running time of one call to x()

  With probability .5, X is 1
  With probability .5, X is 3

  X is a random variable

  The expected value (probabilistic average) of X is .5*1=.5*3=2

  Suppose we run 
  x(); //takes time X
  x(); //takes time Y

  Total time is T=X+Y

  What is expected total time E[T]?

  E[X+Y]=E[X]+E[Y]=E[T]

Hash Tables
-----------
  Random hash code maps each possible key to a randomly chose bucket, but a key's random hash code never changes.

  A good model for how good a hashcode will perform.

  Assume hash table uses chaining, no duplicate keys.

  Perform find(k). k hashes to bucket b.

  Cost of search is one dollar, plus 1 for every entry in bucket b whose key is not k.

  Suppose there are n keys in table besides k.

  V_1, V_2, ..., V_n: random variables for each key K_i

  V_i=1 if k hashes to bucket b.

  Cost of find(k) is
  T=1+V_1+V_2+...+V_n

  Expected cost is E[T]=1+E[V_1]+...E[V_n]

  N buckets. Each key has probability p=1/N of hashing into the same bucket as k

  E[T]=1+n/N

  If load factor n/N <= c, E[T]=O(1)

  Hash table operations all run in O(1) expected amortized time.

Quicksort
---------
  Show that expected avarage of recursive depth for quicksort is log(n).
  Quicksort spends linear time at each levl partitioning lists.
  Assume no 2 keys equal.
  Random pivot: equally likely to be smallest key, second smallest, third smallest, etc.

  For each case, probability is 1/n (since all keys unique).
  Least floor(n/4) and the greatest floor(n/4) are "bad" pivot, since they cause unbalanced lists.
  The others are "good" pivots, since they create balanced trees.

  There are <= n/2 bad pivots, the probabiltiy of choosing bad pivot <=.5.
  The probability of chooseing a good pivot is at least .5.

  Good pivot: 1/4-3/4 split or better
    k goes into subset containing <3/4 of keys
  Bad pivot: k miht go into subset w/ nearly all other keys.

  Let D(n) be random variable = lowest depth at which k appears when we sort n keys.

  E[D(n)]<=1+.5E[D(n)]+.5E[D((3/4)n)]
