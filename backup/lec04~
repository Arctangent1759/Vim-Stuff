======
Memory
======

C Memory Layout
===============
  Program's address space contains 4 regions:
	Stack: local variables, grows downward
	Heap: space requested for pointers via malloc; resizes dynamically, grows upward
	Static Data: global and static variables, does not grow or shrink
	Code: Lodaded when program starts, does noot change

  Declared outside a function:
	Static Data

  Declared inside a function:
	Stack

  Dynamically allocated (malloc):
	Heap

  The Stack
  ---------
	The stack is divided into frames, which are contiguous blocks of memory holding the local variables of a single procedure.
	Last In, First Out data Structure

	A stack frame includes:
	  - Location of caller function
	  - Function arguments
	  - Space for local variables
	
	Stack variables are DEALLOCATED when their functions exit.
	(this means it's a \_really stupid idea\_ to return the address of a local variable)

  Static Data
  -----------
	Place for persistnt variables like String literals, global variables
	Size does not change, but its data can

  Code
  ----
	Copy your code goes here
	Does not change

Dynamic Memory Allocation
=========================
  Sometimes you don't know how much memory you need beforehand like input files, user input.
  Dynamically alocated memory goes on the Heap --- More permanent to the stack

  Allocating Memory
  -----------------
	\_Need to #include <stdlib.h> to use any of this stuff.\_

	malloc(), calloc(), and realloc()

	We focus on malloc(), the most frequently used

	malloc()
	--------
	  malloc():Allocates a continuous block of n bytes of uninitialized memory (contains garbage)
			   Returns a pointer to the beginning o the allocated block; NULL indicates failed request (check for this!)

	  int *p = (int *) malloc(n*sizeof(int));

	  sizeof() makes code more portable

	  malloc returns void*, typecastt will help you catch code errors when pointer types don't match

	  Can use array of poniter syntax to access

	  Make sure you don't lose original address. p++ is a BAD IDEA; use separate pointer

	Release memory on the Heap using free()

	Memory is limited, released when done

	free()
	------
	  Pass it a pointer p to beginning of allocated block; releases the whole block
	  p must be the address originaly returned by m/c/realloc(), otherwise throws system error!
	
	Memory Errors
	-------------
	  Segmentation Fault
		"An error in which a running Unix program attemtps to access memory not allocated to it."

	  Bus Error
		"Illegal Memory Access"
	
	Common Memoy Problems
	---------------------
	  Using uninitialized values -- You copy some garbage into the variable. \_Doesn't throw an error, but causes unpredictable results\_
	  Using memory you don't own -- Dereferencing a NULL is a value, returning a local variable, freeing a struct before freeing its fields, 
									or not allocting space for the null terminator of a string are examples. Causing a segfault
	  Using Memory You Haven't Allocated -- Writing beyond array bounds. May or may not throw error depending on what's after the array.
	  Freeing Invalid Memory -- Freeing stack variables, freeing in the middle o a malloced block, freeing alerady free memory
	  Memory Leaks -- Reassign pointers without freeing. If you have more mallocs than frees, you probably have a memory leak

	  Runtime analysis tols for finding memory errors. Dynamic analysis tol collects information on memory management while program runs. 
	  You will be introduced to Valgrind (memory debugging software) in lab 3/hw 2.

	Memory Management
	-----------------
	  Many calls to malloc() and free() with man different size blocks-where are they placed?
	  Want system to be fast with minimal management overhead.

	  Versus automatic garbage collection of Java.

	  Want to avoid fragmentation (which is breaking memory into tiny bits)

	  Diagram:
		|-----------------|
		|                 |
		|                 |
		|                 |
		|                 |
		|                 |
		|                 |
		|                 |
		|                 |
		|                 |
		|                 |
		|-----------------| (1) malloc(10);
		|                 |
		|-----------------| (2) void *x = malloc(100);
		|                 |
		|                 |
		|                 |  <--Fragmentation!
		|                 |
		|                 |
		|-----------------| (3) free(x); malloc(50); /* Assuming First-fit */
		|                 |
		|                 |
		|                 |
		|                 |
		|                 |
		|                 |
		|-----------------|

	  Simple allocation strategy (K&R 8.7):
		Each block holds its own size and pointer to next block
		free() adds block to the list, combines with adjacent free blocks
		malloc() searches free list for block large enough to meet request
		If multiple blocks are large enough, use one of following:
		  Best-fit: Choose smallest block that fits request
		  First-fit: Choose first blcok that is large enough (always starts from beginning)
		  Next-fit: Lik first fit, but resume from where we last left off

C Wrap-Up
=========
  code:
	/*Simplify struct with typedef*/
	typedef struct Node{
	  char *value;
	  struct Node *next;
    } ListNode;

	/*Can further simplify with pointers*/
	typedef ListNode *List;

	void addNode(String s, List list){
	  List node = (List)malloc(sizeof(NodeStruct));
	  s->value = (String) malloc (strlen(s)+1);
	  strcpy(node->value, s);
	  node->next = list;
	  return node;
	}

	List deleteNode(List list){
	  List temp = list-->next;
	  free(list->value);
	  free(list);
	  return temp;
	}

	Thought exercise: How might you:
	  - Append node to en of a list?
	  - Deelete/free an entire list?
	  - Join two lists together?
	  - Reorder a list alphabetically?
