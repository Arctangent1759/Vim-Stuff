CS 61C Homework 4
Name: Alexander Chu

Login: cs61c-hp

Problem 1

a:
1001001.11
1.00100111e6
s e e e e e n n n n n n n n n n n n n n n n n n n n n n n n n n 
1 1 0 1 0 1 0 0 1 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
1101 0100 1001 1100 0000 0000 0000 0000
d    4    9    c    0    0    0    0

0xd49c0000

b:
1.xxxxxxxxxxxxxxxxxxxxxxxxx*2^(11110-15)+1
1.xxxxxxxxxxxxxxxxxxxxxxxxx*2^(30-15)+1
1.xxxxxxxxxxxxxxxxxxxxxxxxx*2^(15)+1
1111111111111111+1

10000000000000000

c:
0.00000000000000000000000001
2^-26*2*-14
2^-40

d:
0 (-15 Biased)

e:
31 (16 Biased)

Problem 2

a:
The assembler assembles individual .c or .java files, and doesn't know the positions of referenced entities that are outside the current file. The linker takes the generated .o object code, and links them together into an executable. It would only be logical that the absolute addressing occurs in the linker, since the linker is passed all of the files that it is merging together; while the assembler does not know the absolute addresses of instructions in each file, the linker does.

b:
No. The assembler creates independent object code files that act through the interface of their symbol and relocation tables. If a single file is changed, only that file must be recompiled.

c i:
  Symbol

  ii:
  Relocation

  iii:
  Relocation

Problem 3

a:
CR=2*10^9 Clocks/s
Insts/s=100000/.001=100000000
CPI=2^31/100000000=20.0

b:
CR_A=1.1*2^30
CPI_A=1.5
CR_B=1.4*2^30
CPI_B=1.2
CR_A/CPI_A=0.73 Instructions/s
CR_B/CPI_B=1.17 Instructions/s
System B is faster by a factor of 1.6.


c i:
.1*.2=.02

  ii:
1+.1(10+.2(100))=4

  iii:
1+.1(100)=11

d:
CPI_base=1.5
MemRate=.4
CPI_stall=1.5+(.4)(.06)(80)+(.04)(80)=6.62

Problem 4

a i:
  A=16
  C=64B
  K=8B
  O=3
  I=3
  T=16-3-3=10



  ii:
	0xABCD=1010 1011 1100 1101
	0xABCD=1010101111 001 101

	Every address from 0xABC8 to 0xABCF

	0b1010101111001000
	0b1010101111001001
	0b1010101111001010
	0b1010101111001011
	0b1010101111001100
	0b1010101111001101
	0b1010101111001110
	0b1010101111001111

  iii:
	All blocks beginning with the following prefixes:
	0bxxxxxxxxxx001yyy

	where xxxxxxxxxx is a 10 bit binary string not equal to 1010101111
	and
	where yyy is a 3 bit binary string

b i:
  A=16
  C=64B
  K=8B

  I=(64/8)/2=4
  O=3
  T=16-4-3=9

  ii:
	0xABCD=1010 1011 1100 1101
	0xABCD=101010111 1001 101

	0b1010101111001000
	0b1010101111001001
	0b1010101111001010
	0b1010101111001011
	0b1010101111001100
	0b1010101111001101
	0b1010101111001110
	0b1010101111001111

  iii:
	None. The other block in the set may be occupied by any of the addresses that would conflict with 0xABCD's block in the Direct Mapped implementation, which would allow a hit for any of them.
	Hence, there are no guaranteed misses.

c i:
  Maximum:90%
  Minimum:85%

  ii:
  Maximum:85%
  Minimum:85%

  iii:
  Maximum:0%
  Minimum:0%
