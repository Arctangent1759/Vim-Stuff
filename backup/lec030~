Disjoint Sets (Union-Find data strcutures)
==========================================
	Every item is in exactly one set.
	2 operations:
		Union merges 2 sets into 1
		Find takes an item; tells us what set it's in
	
	Initially, every item is in its own set.

		|Piedmont Air| |Empire Air| |US Air| |Pacific Southwest| |Web TV| |Microsoft|

		find(Empire Air)-->Empire Air

		union(Piedmont Air, Empire Air) as Piedmont Air
		union(US Air, Pacific Southwest) as US Air
		union(Web TV, Microsoft) as Microsoft

		find(Empire Air)-->Piedmont Air

		union(Piedmont Air, US Air) as US Air

		find(Empire Air)-->US Air
	
	List-Based Disjoint Sets and the Quick-find Algorithm
	-----------------------------------------------------
		Each set references list of items in that set.
		Each item has 1 reference to the set that contains it.

		Find: O(1) time

		Union: slow (change all references) O(n)

	Tree-Based Disjoint Sets and the Quick-Union algorithm
	------------------------------------------------------
		Union: O(1) time
		Find: A bit slower

		Quick union is faster overall than quick-find

		Each set stored as a tree.

		Data strcuture is a forest.
		Each item is initially root of its own tree.

		Trees are merged as sets are merged.
		Don't need child or sibling references; only parent.

		True identity of each set is recorded at root.

		union(): make the root of one set be child of root of other set.

		plaintext:
			Piedmont Air----------->US Air
				^					  ^
				|					  |
			Empire Air				Pacific Southwest

		find(): follow parent references fromitem to root of tree.
	
		Optimization
		------------
			union-by-size:
			--------------
				At each root, record dize of tree.
				Make smaller treea subtree of larger tree.

			Implementing Quick-Union wih an Array
			-------------------------------------
				Items numbered from zero.
				Array records parent of each item.
				If item has no parent, record size s of its tree as negative number s
				-1|-1|-1|-1|-1|-1|-1|-1|-1
				0  1  2  4  5  6  7  8  9

				Merge 5 with 4, 5 with 8, 3 with 8
				Merge 9,0,6 with 1

				1|-4|-1|5|8|7|1|3|-5|1
				Negative numbers are sizes, positive numbers are references to other nodes

				Code:
					public void union(int root1, int root2){
						if (array[root2]<array[root1]){//Root2 size is GREATER than root1 size
							array[root2]+=array[root1];
							array[root1]=root2;
						}
					}

			Path Compression
			----------------
					  0							    0
					 /|\						 -------
					1 2 3						 / /|\ \ 
				   /|\			--find(7)-->	7 4 1 2 3
				  4 5 6							 /| |\
				 /|\							8 9 5 6
				7 8 9

				Code:
					public int find(int x){
						if (array[x]<0){
							return x;
						}else{
							array[x]=find(array[x]);
							return array[x];
						}
					}

				Running Time
					union: Theta(1) time
					Find(): Theta(log u) worst case, u is the number of unions, average time close to constant
