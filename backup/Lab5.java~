public class Lab5 {
	public static void main(String[] args){
		System.out.println("=======================================================================");
		System.out.println("---------------------------Commencing Tests----------------------------");
		System.out.println("=======================================================================");





		X[] xa = new X[5];
		Y[] ya = new Y[5];
		xa=ya;
		ya=(Y[])xa;
		//Ia: A cast is only required for binding ya to xa.

		xa = new X[5];
		ya = new Y[5];
		for (int i = 0; i < ya.length; i++){
			ya[i]=new Y();
		}
		xa=ya;
		ya=(Y[])xa;
		//Ib: A cast is only required for binding ya to xa.
		
		xa = new X[5];
		ya = new Y[5];
		for (int i = 0; i < xa.length; i++){
			xa[i]=new X();
		}
		try{
		ya=(Y[])xa;
		}
		catch (ClassCastException e){
			System.out.println("ClassCastException Thrown.");
		}
		//Ic: Nope! xa cannot be casted to Y[]. Throws an ClassCastException. This matters because each element in xa must be casted to Y.
		//If the elements are not all Ys, then the compiler would normally throw a ClassCastException.
	
		//IIa:Java compiles. The class inherits the method required by the interface.
		//IIb:Java does not compile, since the method prototype is inconsistent with the interface Any attempt to implement the method, however, will result in additional errors..
		//IIc:Java will compile if the subclass or superclass also contain a method that matches the interface method's prototype.
		//IId:Java compiles, because the particular name of parameters doesn't matter.
		
		//IIIa:Java compiles if the constant is not accessed.
		//IIIb:Java does not compile if the constant is accessed.
		System.out.println();
		D d = new D();
		//IIIc:Use [Class/Interface Name].[Constant]
		

		System.out.println();
		d.morePointlessMethod();
		((C) d).morePointlessMethod();
		//IVa: No, because of dynamic method lookup.
		C c = new C();
		try{
		((D) c).morePointlessMethod();
		}
		catch (ClassCastException e){
			System.out.println("ClassCastException Thrown.");
		}
		//IVb: Neither. Causes a ClassCastException because c is not a D.
		d.superPointlessMethod();
		//IVc: Neither. Causes a ClassCastException because c is not a D.
		


		System.out.println("_______________________________________________________________________");
	}
}
class X{
	public X(){
		System.out.println("Constructing X");
	}
	public String toString(){
		return "X";
	}
}
class Y extends X{
	public Y(){
		System.out.println("    that's actually a Y");
	}

	public String toString(){
		return "Y";
	}

}

class C{
	public static final String s = "Pizza is not a vegetable.";
	/*
	public int pointlessMethod(String s){
		System.out.println("A toast to not being on fire!");
		return 1;
	}
	*/
	public void pointlessMethod(int i){
		System.out.println("A toast to not being on fire!");
	}
	public void pointlessMethod(String t){
		System.out.println("A toast to not being on fire!");
	}
	public void morePointlessMethod(){
		System.out.println("Superclass Method.");
	}

}
interface I{
	public static final String s = "Glory to our giant cat/pylon overlords.";
	//public static final String s = "Pizza is not a vegetable.";
	public void pointlessMethod(String s);
}
class D extends C implements I{
	public D(){
		//System.out.println("Superclass Constant: "+s);
		System.out.println("Superclass Constant: "+C.s);
		System.out.println("Interface Constant: "+I.s);
	}
	public void morePointlessMethod(){
		System.out.println("Subclass Method.");
	}
	public void superPointlessMethod(){
		super.morePointlessMethod();
	}
}
