/* HashTableChained.java */

package dict;
import list.DList;
import list.ListNode;
import list.InvalidNodeException;

/**
 *	HashTableChained implements a Dictionary as a hash table with chaining.
 *	All objects used as keys must have a valid hashCode() method, which is
 *	used to determine which bucket of the hash table an entry is stored in.
 *	Each object's hashCode() is presumed to return an int between
 *	Integer.MIN_VALUE and Integer.MAX_VALUE.	The HashTableChained class
 *	implements only the compression function, which maps the hash code to
 *	a bucket in the table's range.
 *
 *	DO NOT CHANGE ANY PROTOTYPES IN THIS FILE.
 **/

public class HashTableChained implements Dictionary {

	/**
	 *	Place any data fields here.
	 **/
	protected DList[] buckets;
	protected int size;



	/** 
	 *	Construct a new empty hash table intended to hold roughly sizeEstimate
	 *	entries.	(The precise number of buckets is up to you, but we recommend
	 *	you use a prime number, and shoot for a load factor between 0.5 and 1.)
	 **/

	public HashTableChained(int sizeEstimate) {
		//Find closest prime to sizeEstimate
		while (!isPrime(sizeEstimate)){
			sizeEstimate++;
		}
		buckets=new DList[sizeEstimate];
		for (int i = 0; i < buckets.length; i++){
			buckets[i]=new DList();
		}
		size=0;
	}
	protected boolean isPrime(int n){
		for (int i = 2; i <= Math.sqrt(n); i++){
			if (n%i==0){
				return false;
			}
		}
		return true;
	}

	/** 
	 *	Construct a new empty hash table with a default size.	Say, a prime in
	 *	the neighborhood of 100.
	 **/

	public HashTableChained() {
		this(101);
	}

	/**
	 *	Converts a hash code in the range Integer.MIN_VALUE...Integer.MAX_VALUE
	 *	to a value in the range 0...(size of hash table) - 1.
	 *
	 *	This function should have package protection (so we can test it), and
	 *	should be used by insert, find, and remove.
	 **/

	int compFunction(int code) {
		return Math.abs(code%buckets.length);
	}

	/** 
	 *	Returns the number of entries stored in the dictionary.	Entries with
	 *	the same key (or even the same key and value) each still count as
	 *	a separate entry.
	 *	@return number of entries in the dictionary.
	 **/

	public int size() {
		return size;
	}

	/** 
	 *	Tests if the dictionary is empty.
	 *
	 *	@return true if the dictionary has no entries; false otherwise.
	 **/

	public boolean isEmpty() {
		return size==0;
	}

	/**
	 *	Create a new Entry object referencing the input key and associated value,
	 *	and insert the entry into the dictionary.	Return a reference to the new
	 *	entry.	Multiple entries with the same key (or even the same key and
	 *	value) can coexist in the dictionary.
	 *
	 *	This method should run in O(1) time if the number of collisions is small.
	 *
	 *	@param key the key by which the entry can be retrieved.
	 *	@param value an arbitrary object.
	 *	@return an entry containing the key and value.
	 **/

	public Entry insert(Object key, Object value) {
		Entry out = new Entry();
		out.key=key;
		out.value=value;
		buckets[compFunction(key.hashCode())].insertFront(out);
		size++;
		return out;
	}

	/** 
	 *	Search for an entry with the specified key.	If such an entry is found,
	 *	return it; otherwise return null.	If several entries have the specified
	 *	key, choose one arbitrarily and return it.
	 *
	 *	This method should run in O(1) time if the number of collisions is small.
	 *
	 *	@param key the search key.
	 *	@return an entry containing the key and an associated value, or null if
	 *					no entry contains the specified key.
	 **/

	public Entry find(Object key) {
		ListNode curr = buckets[compFunction(key.hashCode())].front();
		while (curr.isValidNode()){
			try{
				if (((Entry)curr.item()).key().equals(key)){
					return ((Entry)curr.item());
				}
				curr=curr.next();
			}catch (InvalidNodeException e){
				System.out.println("BAD BAD BAD (FIND)");
				System.exit(1);
			}
		}
		return null;
	}

	/** 
	 *	Remove an entry with the specified key.	If such an entry is found,
	 *	remove it from the table and return it; otherwise return null.
	 *	If several entries have the specified key, choose one arbitrarily, then
	 *	remove and return it.
	 *
	 *	This method should run in O(1) time if the number of collisions is small.
	 *
	 *	@param key the search key.
	 *	@return an entry containing the key and an associated value, or null if
	 *					no entry contains the specified key.
	 */

	public Entry remove(Object key) {
		ListNode curr = buckets[compFunction(key.hashCode())].front();
		size--;
		while (curr.isValidNode()){
			try{
				if (((Entry)curr.item()).key().equals(key)){
					Entry out = (Entry)curr.item();
					curr.remove();
					return out;
				}
				curr=curr.next();
			}catch (InvalidNodeException e){
				System.out.println("BAD BAD BAD (REMOVE)");
				System.exit(1);
			}
		}
		return null;
	}

	/**
	 *	Remove all entries from the dictionary.
	 */
	public void makeEmpty() {
		buckets=new DList[buckets.length];
		size=0;
		for (int i = 0; i < buckets.length; i++){
			buckets[i]=new DList();
		}
	}
	public static void main(String[] args){
		HashTableChained h = new HashTableChained();
		h.insert("abc",1);
		h.insert("def",2);
		h.insert("ghi",3);
		//try{
		//System.out.println(((Entry)(h.buckets[h.compFunction("ghi".hashCode())].front().item())).value());
		//}catch(InvalidNodeException e){}
		System.out.println(h.find("abc").value());
		System.out.println(h.find("def").value());
		System.out.println(h.find("ghi").value());
		System.out.println(h.remove("abc").value());
		System.out.println(h.find("abc")==null);
		System.out.println(h.find("def")==null);
		System.out.println(h.find("ghi")==null);
		System.out.println(h.size());
		h.makeEmpty();
		System.out.println(h.size());
		System.out.println(h.find("abc")==null);
		System.out.println(h.find("def")==null);
		System.out.println(h.find("ghi")==null);
	}
	public void histogram(){
		String out="";
		for (int i = 0; i < buckets.length; i++){
			for (int j = 0; j < buckets[i].length(); j++){
				out+="x";
			}
			out+="\n";
		}
		System.out.println(out);
	}
	public int getCollisions(){
		int out=0;
		for (int i = 0; i < buckets.length; i++){
			for (int j = 0; j < buckets[i].length(); j++){
				out+="x";
			}
			out+="\n";
		}
		System.out.println(out);
	}

}
