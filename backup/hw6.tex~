% Search for all the places that say "PUT SOMETHING HERE".

\documentclass[11pt]{article}
\usepackage{amsmath,textcomp,amssymb,graphicx}
\usepackage{tikz,pgfplots}
\usetikzlibrary{arrows}

\def\Name{Alexander Chu}  % Your name
\def\Sec{107, Yun Park}  % Your GSI's name and discussion section
\def\Login{cs170-ix} % Your login
\def\Homework{5}%Number of Homework, PUT SOMETHING HERE
\def\Session{Fall 2013}


\title{CS170--Fall 2013 --- Solutions to Homework 2}
\author{\Name, section \Sec, \texttt{\Login}}
\markboth{CS170--\Session\  Homework \Homework\ \Name, section \Sec}{CS170--\Session\ Homework \Homework\ \Name, section \Sec, \texttt{\Login}}
\pagestyle{myheadings}

\usepackage[margin=0.125in]{geometry}

\begin{document}
\maketitle
\textbf{Collaborators}: Robert Chang, Rohan Chitnis, Jong Ahn, Leo Wu

\section*{Problem 1}
\label{pg:end-of-p1}
\subsection*{Part (a)}
1. Move the sheep accross\\
2. Sail back.\\
3. Move the cabbage across\\
4. Move the sheep back.\\
5. Move the wolf across.\\
6. Move back.\\
7. Move the sheep across.\\
\\
\\
\subsection*{Part (b)}
The state-space graph for this problem is as follows:
(We use the notation [characters on the left bank][characters on the right bank], where F is the farmer, S is the sheep, C is the cabbage, and W is the wolf.
\begin{verbatim}
                        [W][SCF]----[WSF][C]
                            |           |
[SWCF][]----[WC][FS]----[WCF][S]    [S][WCF]----[S][WCF]----[SF][WC]----[][WCSF]
                            |           |
                        [C][SWF]----[CSF][W]
\end{verbatim}

From the graph, we see that there are $\boxed{\mbox{2 solutions}}$ that are the shortest path through the graph.


% Make sure that the solution here does not exceed one page here. If
% it does, use the extra space for this problem at the end.  
%
% Comment out the next line if you are NOT using the extra space
\paragraph{} \emph{Continued on Page \pageref{pg:p1-continuation}}
\newpage


%%Do NOT remove/comment the next line
\pagestyle{plain}


%%It makes sure your name appears only on the first page
\section*{Problem 2}
\label{pg:end-of-p2}

\textbf{Main Idea:}\\
The graph is a DAG of strongly connected components. Observe that nodes connected by roads can be collapsed into supernodes connected only by directed edges.
Also observe that dijkstra's algorithm can be modified to handle DAGs with negative edges; simply linearize the graph with a DFS, and process the nodes in linearized order.
\\
In our algorithm, there are two kinds of costs.
Transit costs are costs from moving between nodes with flights. In other words, these are the costs incurred from moving between airports through roads.
Flight costs are the costs of actual flights.
Since the graph can be broken down into a metagraph of strongly connected components, we can collapse nodes connected by roads into supernodes.
However, we have to update the cost of each flight to take into account the cost of getting to the airport, so we add the transit cost to the cost of each directed edge.
We use dijkstra's algorithm to find the transit cost within a strongly connected component.
We then use the above described modification on dijkstra's algorithm to compute the shortest path through the metagraph.
Every time we encounter a node with an undirected edge, we again compute the transit cost and refer back to the metagraph to resume our computation.
\\
\textbf{Pseudocode:}\\
\begin{verbatim}
Procedure find_best_route(G,startNode,endNode):
    metagraph = get_strongly_connected_components(G)
    linearize(metagraph)
    currNode=startNode
    for each u in metagraph.vertices: 
        currNode=getRecievingAirport(u,v)
        transitCosts = dijkstra(u.getSubGraph())
        for each edge (u,v) in u.edges:
            setEdgeCost(u,v,getEdgeCost(u,v)+transitCosts(currNode,v))
            update(u,v)
            #Mark the node in v's subgraph that we start in for the next iteration
            v.setRecievingAirport(G.getEdge(u,v)[1]) 
    return get_shortest_path_from_node_dists(G)
    
\end{verbatim}
\textbf{Proof of Correctness:}\\
All undirected edges (u,v) can be replaced with two directed edges (u,v) and (v,u). Hence, any n cities connected by roads must be a stronly connected components.
As per the problem specification, there are no plane dfs back edges. Hence, the graph is a DAG of supernodes connected by roads.
Since linearizing a DAG and updating its edges in linearized order computes a shortest path even in the presence of negative edges, our algorithm computes a solution if no roads are present.
However, since roads are present, the modification that we change directed edge costs based on transit costs is necessary.
We know that Dijkstra's algorithm computes the shortest path in any graph with no negative edges. 
Hence, we can compute transit costs by running Dijkstra's algorithm on each subgraph of roads, since, as per the problem specification, there are no negative roads.
Since we can compute the transit costs and add them to the flight costs, we now have a DAG with edges that take into account the undirected edges.
The linearized DAG modification of Dijkstra's algorithm can now compute the shortest path through the entire graph.
\\
\textbf{Running Time:}\\
$O(|V|log |V|+|E|)$
\\
\textbf{Running Time Analysis:}\\
This algoithm runs Dijkstra's algorithm incrementally throughout the entire graph. 
The prinicple limitation is the need to process nodes in order of weight in computing the transit costs.
This computation requires |V|log|V| time due to the limitations of the priority queue data structure.
As always, each edge is processed exactly once, so the total runtime is $O(|V|log |V|+|E|)$.


%Insert solution here

% Make sure that the solution here does not exceed one page here. If
% it does, use the extra space for this problem at the end.  
%
% Comment out the next line if you are NOT using the extra space
\paragraph{} \emph{Continued on Page \pageref{pg:p2-continuation}}



\newpage

\section*{Problem 3}
\label{pg:end-of-p3}

\subsection*{Part (a)}

\textbf{Main Idea:}\\
We transform each edge such that add edges instead of multiplying them, to get the true cost.
We observe that the ideal operator for this would be the log, which turns multiplications into additions:\\
$\frac{1}{cost(P)}=\prod_{r_{i,j} \in P} r_{i,j}$\\
$-log(cost(P))=\sum_{r_{i,j} \in P} log(r_{i,j})$\\
$log(cost(P))=\sum_{r_{i,j} \in P} -log(r_{i,j})$\\
So we replace each edge cost $c$ with $-log(c)$, and run the Bellman Ford algorithm on the new graph.
Then, we take the returned cost $-log(R)$, and invert the log, returning $2^{--log(R)}=R$
\\
\textbf{Pseudocode:}\\
\begin{verbatim}
Procedure find_best_transaction(G,start_currency_node,end_currency_node):
    for edge in G:
        edge.cost=-log(edge.cost)
    transformed_cost, minimum_path = Bellman_Ford(graph=G,startNode=start_currency_node,end_currency_node)
    return (2^(-transformed_cost), minimum_path)

Procedure Bellman_Ford(graph, startNode, endNode):
    for u in graph.vertices:
        dist(u)=infinity
        prev(u)=infinity
        dist(startNode)=0
        repeat |V|-1 times:
            for e in graph.edges:
                update(e)
        #shortest_path_between uses a BFS to find the shortest path through the sequence of nodes to endNode
        return (dist(endNode),shortest_path_between(startNode,endNode)) 
\end{verbatim}

\textbf{Proof of Correctness:}\\
Since log is a monotonic increasing function, it preserves the ordering of the transaction rates.
Since we want to maximize the transaction rate, we want to minimize the recipricol of the total transaction rate.
$log(\frac{1}{r_{i,j}})=-log(r_{i,j})$. Since adding logs yields the product of the operands, our transformation of the graph represents the problem accurately.
We know the Bellman Ford Algorithm correctly computes the minimum path from start node to end node, and the cost of said path, even in the presence of negative edges (which result from transaction rates >1).
Hence, the algorithm correctly computes the optimum path and its cost.
\textbf{Running Time:}\\
$O(|V||E|)$
\textbf{Running Time Analysis:}\\
Transforming all the edges takes $O(|E|)$ time.
Bellman Ford take $O(|V||E|)$ time to run.
$|V||E|+|E|=\boxed{O(|V||E|)}$


% Make sure that the solution here does not exceed one page here. If
% it does, use the extra space for this problem at the end.  
%
% Comment out the next line if you are NOT using the extra space
\paragraph{} \emph{Continued on Page \pageref{pg:p3-continuation}}




\newpage

\section*{Problem 4}
\label{pg:end-of-p4}
\subsection*{Part (a)}
In a graph G with minimum spanning tree T, let e=(u,v). Let S be a set containing only u.
The cut property states that the minimum spanning tree contains
only the lightest edge from u to any other vertex, say u'.
Since (u,v) is the heaviest edge in a cycle, by definition of cycle,
it is gaurunteed that there exists another edge from u that is 
lighter than (u,v). Hence, (u,v) will not be included in T.
Append u' to S and repeat. When the next lightest edge f from S
to the rest of the graph goes to v, v can either e or f can be 
added to T. By the cut property, the lightest edge,
f, will be added to T. Now, suppose for contradiction that e
is part of the minimum spanning tree T. Since f and e both 
connect S to v, e will create a cycle in T. Since minimum
spanning trees do not contain cycles, e cannot be part of the
minimum spanning tree. Hence, no minimum spanning tree contains
e, the heaviest edge in a cycle.
\subsection*{Part (b)}
By our property from part (a):\\
edge e is the highest cost edge in a cycle $\implies$ e is not in the minimmum spanning tree\\
By contraposition,
e is in the minimum spanning tree $\implies$ e is not the highest cost edge in a cycle\\
The property from part (a) implies by contraposition that a minimum spanning tree can be generated by removing all edges that are the heaviest edges in a cycle.
The algorithm does this; since the list of edge is sorted by weight, it is gaurunteed that an edge with a higher weight is processed before an edge with a lower weight.
If the edge is in a cycle, it is removed, rendering the rest of the edges in the cycle that are not involved in other cycles safe from removal.
But the edges are processed in decreasing order of weight, so the heaviest edge in each cycle is always removed first.
Hence, what is left when all edges are processed is a minimum spanning tree of the graph.
\subsection*{Part (c)}
\textbf{Main Idea:}\\
A cycle between vertices u and v exists in an undirected graph if there exist more than one path from u to v.
Let e=(u,v). Remove e. Edge e is in a cycle if and only if there is still a path from u to v. 
We check this by running DFS's explore operation from u and checking for v.
\textbf{Pseudocode:}\\
\begin{verbatim}
Procedure check_cycle(graph,edge):
    u,v=edge.vertices
    graph.remove(edge)
    stack=makeStack(u)
    while stack is not empty:
        curr=stack.pop()
        if curr.visited:
            continue
        curr.visited=True
        if curr==v:
            return True
        stack.pushAll(curr.getNeighbors)
    return False
\end{verbatim}
\textbf{Proof of Correctness:}\\
By definition of cycle, if two vertices u and v are in a cycle, there exist at least 2 distinct paths between u and v.
If we remove e, which connects some u to some v, and there still exists a path from u to v, then there are at least two paths from u to v, and there is a cycle in the graph.
We do exactly this; remove e and check if v is still reachable from u via dfs.
Since DFS explore traverses all vertices connected to its start node, it is gaurunteed that we find a path from u to v if one exists.
Hence, we can correctly detect if edge e is in a cycle.
\textbf{Running Time:}\\
$O(|V|+|E|)$
\textbf{Running Time Analysis:}\\
Depth first search takes O(|V|+|E|) time to run. Our only modification was to add a constant time check to the operation, which does not change the overall runtime.


% Make sure that the solution here does not exceed one page here. If
% it does, use the extra space for this problem at the end.  
%
% Comment out the next line if you are NOT using the extra space
\paragraph{} \emph{Continued on Page \pageref{pg:p4-continuation}}


\newpage

\section*{Problem 5}
\label{pg:end-of-p5}

\subsection*{Part (a)}
\textbf{Main Idea:}\\
Increasing the cost of an edge that is not in the minimum spanning tree should not change the minimum spanning tree, so we do nothing.
\\
\textbf{Pseudocode:}\\
Do nothing.
\\
\textbf{Proof of Correctness:}\\
Suppose for contradiction, that edge e is in the new minimum spanning tree.
Since adding e would create a cycle in the tree, another edge, f, must be removed.
Since f is in the minimum spanning tree, and it exists in a cycle with e, removing f and e from the minimum spanning tree creates two sets U and V of edges.
Since this is the only cycle in the tree, only e and f move across the sets.
By the cut theorem, the min edge connecting U and V must be part of the MST.
f is the min edge, and is part of the minimum spanning tree. Hence, e cannot be part of the minimum spanning tree. Contradiction reached.
Hence, we do not need to change the minimum spanning tree.
\textbf{Running Time:}\\
O(1)
\\
\textbf{Running Time Analysis:}\\
Doing nothing takes constant time.


\subsection*{Part (b)}
\textbf{Main Idea:}\\
Edge e connects some vertex u to some vertex v.
Use DFS to find the path from u to v in the minimum spanning tree T.
From the list of each edge on the path from u to v, remove the most expensive edge. If e is not the most expensive edge, add it to the graph.
\textbf{Pseudocode:}\\
\begin{verbatim}
Procedure update_T(G,T,e,newWeight):
    u,v = e.vertices
    stack=makeStack(u,[u])
    while stack is not empty:
        curr,path=stack.pop()
        if curr.visited:
            continue
        curr.visited=True
        if curr==v:
            break
        for neighbor in getNeighbors(T,curr):
            stack.push(neighbor,path+neighbor)
    edges=[T.getEdge(path[i],path[i+1]) for i in range(len(path))-1]+e #Generate edge sequence from list of vertices on path
    G.remove(max(edges))
    if e!=max(edges):
        G.add(e)

\end{verbatim}
\textbf{Proof of Correctness:}\\
We take set of edges P on the full path from u to v in T where e connects u and v.
The union of P and e forms a cycle in T.
By the property we proved in problem (4.a), the heaviest edge in a cycle is not in the minimum spanning tree.
In the algorithm, we enforce this by removing the most expensive edge from P, and adding the rest to T.
Hence, we correctly update T.
\textbf{Running Time:}\\
$O(|V|+|E|)$
\\
\textbf{Running Time Analysis:}\\
We run a single dfs, and iterate through the edges. In the worst case, we run that dfs to completion.
Hence, the runtime is $O(|V|+2|E|)=\boxed{O(|V|+|E|)}$.


%Insert solution here


% Make sure that the solution here does not exceed one page here. If
% it does, use the extra space for this problem at the end.  
%
% Comment out the next line if you are NOT using the extra space
\paragraph{} \emph{Continued on Page \pageref{pg:p5-continuation}}


\newpage


%% Comment out the "extra spaces" completely for the problems for you
%% don't need them

\section*{Extra space for Problem 1}
\emph{Continued from Page \pageref{pg:end-of-p1}}\\

%Insert solution here


\label{pg:p1-continuation}

\newpage
%%Comment out the above three lines if you are not using extra space
%%for this problem.


\section*{Extra space for Problem 2}
\emph{Continued from Page \pageref{pg:end-of-p2}}\\

%Insert solution here

\label{pg:p2-continuation}
\newpage
%%Comment out the above three lines if you are not using extra space
%%for this problem.


\section*{Extra space for Problem 3}
\label{pg:p3-continuation}
\emph{Continued from Page \pageref{pg:end-of-p3}}\\
\subsection*{Part (b)}
\textbf{Main Idea:}\\
We know that running an extra iteration of the Bellman Ford Algorithm and checking for changes in the edge costs will determine whether or not a negative cycle exists.
Since the negative log of a cycle with a positive product of transaction rates is negative, a negative cycle is indicative of an exchange rate anomaly.
\textbf{Pseudocode:}\\
\begin{verbatim}
Procedure find_anomaly(G,start_currency_node,end_currency_node):
    for edge in G:
        edge.cost=-log(edge.cost)
    #Bellman ford with extra iteration
    for u in graph.vertices:
        dist(u)=infinity
        prev(u)=infinity
        dist(startNode)=0
        repeat |V|-1 times:
            for e in graph.edges:
                update(e)
        #Extra iteration
        for e in graph.edges:
            temp=e
            update(e)
            if e!=temp:
                return True
        return False
\end{verbatim}
\textbf{Proof of Correctness:}\\
As shown before, the negative log transformation produces an accurate representation of the problem, where negative cycles are equivalent to transaction cycles with a product greater than one.
All that is left is to show that running an extra iteration of Bellman Ford detects negative cycles.
In a graph with a negative cycle, there is no shortest path, because the value of a node or after the cycle can go to infinity as the cycle is traversed an infinite number of times.
Running update on all edges |V|-1 times causes convergence of the values of all edges in a graph without negative cycles, because every vertex has taken into account the edges of all other vertices.
Running an extra iteration of updates, hence, does nothing in a graph without negative cycles, as edges have all reached their optimal values.
However, in a negative cycle, since the lower bound goes to negative infinity, running an extra iteration of updates will cost some of the edge costs to decrease.
Hence, detecting a change in the edges on an extra iteration of Bellman Ford also detects negative cycles.
Hence, our algorithm detects transaction anomalies correctly.
\textbf{Running Time:}\\
$O(|V||E|)$
\textbf{Running Time Analysis:}\\
Transforming all the edges takes $O(|E|)$ time.
Bellman Ford with an extra iteration take $O(|V||E|+1)$ time to run.
$|V||E|+|E|+1=\boxed{O(|V||E|)}$

%Insert solution here

\newpage
%%Comment out the above three lines if you are not using extra space
%%for this problem.



\section*{Extra space for Problem 4}
\emph{Continued from Page \pageref{pg:end-of-p4}}\\
\label{pg:p4-continuation}

\subsection*{Part (d)}
$\boxed{O(|E|^2)}$\\
We run a linear time $O(|V|+|E|)$ check to see if a given edge is in a cycle for each of the |E| edges in the graph.
This totals to O(|E|(|V|+|E|)) operations.
Given that there are |E| edges, there are at most |V|=2|E| vertices (each edge connects two distinct vertices).
Hence, we have O(|E|(3|E|)) operations = $O(|E|^2)$


\newpage
%%Comment out the above three lines if you are not using extra space
%%for this problem.



\section*{Extra space for Problem 5}
\emph{Continued from Page \pageref{pg:end-of-p5}}\\

\label{pg:p5-continuation}

\subsection*{Part (c)}
\textbf{Main Idea:}\\
Decreasing the cost of an edge that is in the minimum spanning tree should not change the minimum spanning tree, so we do nothing.
\\
\textbf{Pseudocode:}\\
Do nothing.
\\
\textbf{Proof of Correctness:}\\
Suppose for contradiction, that edge e is not in the new minimum spanning tree.
Since removing e would disconnect T, as every edge in the minimum spanning tree is a bridge, some other edge f in G but not in T must be added to the graph.
Edges f and e form a cycle in T if both exist in the graph.
Construct two sets of vertices U and V, such that only f and e span the gap between the two sets.
By the cut theorem, only the smaller of the two edges must be in the minimum spanning tree.
Since e was in the tree originally, and its cost only got smaller, its cost should still be less than that of f.
Hence, e is still in the minimum spanning tree. Contradiction reached.
Hence, we do not need to change the minimum spanning tree.

\textbf{Running Time:}\\
O(1)
\\
\textbf{Running Time Analysis:}\\
Doing nothing takes constant time.

\subsection*{Part (d)}
\textbf{Main Idea:}\\
Edge e connects some vertex u to some vertex v.
Remove e from the T.
Use a DFS explore from u to find all nodes in T connected to u.
Use a DFS explore from v to find all nodes in T connected to v. These should be mutually exclusive sets.
Find the minimum edge that connects any vertex reachable from u to any vertex reachable fom v and add it to the graph.
\textbf{Pseudocode:}\\
\begin{verbatim}
Procedure update_T(G,T,e,newWeight):
    u,v = e.vertices
    G.remove(e)
    reachable_from_u=set(DFS_explore(graph=T,start=u).getVerticesExplored)
    reachable_from_v=set(DFS_explore(graph=T,start=v).getVerticesExplored)
    best=e
    for edge in graph:
        if (edge.vertices[0] in reachable_from_u and edge.vertices[1] in reachable_from_v)
            or (edge.vertices[0] in reachable_from_v and edge.vertices[1] in reachable_from_u)
            if edge.weight<best.weight:
                best=weight
    T.add(best)
\end{verbatim}
\textbf{Proof of Correctness:}\\
We observe that in a minimum spanning tree, every edge is a bridge. That is, removing any edge would disconnect the graph.
When we remove e, we hence disconnect G into two sets: the set U of nodes reachable from u and the set V of nodes reachable from v.
By the cut theorem, the minimum edge in G connecting U and V must be in the minimum spanning tree.
Our algorithm does this by iterating through all edges in G, finding the minimum cost edge that connects U and V, and adding it to the graph.
Hence, we correctly update T.
\\
\textbf{Running Time:}\\
$O(|V|+|E|)$
\\
\textbf{Running Time Analysis:}\\
We run a dfs on each half of the tree in O(|V|+|E|) time. 
We then run iterate through the edges, checking the weight of those that connect the two sets in O(|E|) time.
$O(|V|+2|E|)=\boxed{O(|V|+|E|)}$.


\newpage
%%Comment out the above three lines if you are not using extra space
%%for this problem.



\end{document}
