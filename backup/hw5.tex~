% Search for all the places that say "PUT SOMETHING HERE".

\documentclass[11pt]{article}
\usepackage{amsmath,textcomp,amssymb,graphicx}
\usepackage{tikz,pgfplots}
\usetikzlibrary{arrows}

\def\Name{Alexander Chu}  % Your name
\def\Sec{107, Yun Park}  % Your GSI's name and discussion section
\def\Login{cs170-ix} % Your login
\def\Homework{5}%Number of Homework, PUT SOMETHING HERE
\def\Session{Fall 2013}


\title{CS170--Fall 2013 --- Solutions to Homework 2}
\author{\Name, section \Sec, \texttt{\Login}}
\markboth{CS170--\Session\  Homework \Homework\ \Name, section \Sec}{CS170--\Session\ Homework \Homework\ \Name, section \Sec, \texttt{\Login}}
\pagestyle{myheadings}

\usepackage[margin=0.125in]{geometry}

\begin{document}
\maketitle
\textbf{Collaborators}: Robert Chang, Rohan Chitnis, Jong Ahn, Leo Wu

\section*{Problem 1}
\subsection*{Part (a)}
L is tree-structured with a root at s. By definition of tree graph, each node has an indegree of at most 1. Hence, for each node, there is at least most one parent node.
It follows that $E \in O(|V|)$. The runtime of a depth first search is normally $O(V+E)$. Since $E=O(|V|)$, $|V|+|E|=2|V|=\boxed{O(|V|)}$.
\subsection*{Part (b)}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]
    \node[main node](0){s};
    \node[main node](1)[below left of=0]{A};
    \node[main node](2)[below of=1]{B};
    \node[main node](3)[below right of=0]{C};
    \path[every node/.style={font=\sffamily\small}]
        (0) edge node [left] {1} (1)
        (0) edge node [left] {2} (3)
        (1) edge[bend right] node [left] {3} (2)
        (2) edge[bend right] node [right]  {4} (1)
        (3) edge[dashed] node [dashed]  {5} (2);
\end{tikzpicture}\\

Graph starts at $s$. We add edge $(C,B)$.\\

Suppose the traversal order without $(C,B)$ is edge s,C,A,B (we can do this because we can choose the tiebreaking policy). 
L contains edges 1,2, and 3.
Now, we add $(C,B)$. 
Performing DFS under the same tiebreaking policy yields L containing edges 2,5, and 4. This is the correct tree that our algorithm should return.
If C(G,e) returns false,  L contains 1,2, and 3, as before.
If C(G,e) returns true,  L contains 1,2,5, and 4, which is not even a valid DFS tree.
Neither are equal to the correct tree. Hence, the algorithm fails to add the edge while keeping L intact under the same tie-breaking policy.\\

\label{pg:end-of-p1}


%Insert solution here


% Make sure that the solution here does not exceed one page here. If
% it does, use the extra space for this problem at the end.  
%
% Comment out the next line if you are NOT using the extra space
\paragraph{} \emph{Continued on Page \pageref{pg:p1-continuation}}
\newpage


%%Do NOT remove/comment the next line
\pagestyle{plain}
%%It makes sure your name appears only on the first page
\section*{Problem 2}
\subsection*{Part (a)}

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]
    \node[main node](1){1};
    \node[main node](2)[right of=1]{2};
    \path[every node/.style={font=\sffamily\small}]
        (1) edge[bend right] node [left] {} (2)
        (2) edge[bend right] node [right]  {} (1);
\end{tikzpicture}\\

Suppose we add a first. Now we add b. The edge from b to a cannot exist, because a existed in the graph before b.\\
Suppose we add b first. Now we add a. The edge from a to b cannot exist, because b existed in the graph before a.



\subsection*{Part (b)}
P =  G is a Directed Acyclic Graph.\\

We first prove that if a graph is a dag, then it can be constructed by the algorithm.\\
\textbf{Base Case:}\\
A graph consisting of one node can be constructed by the algorithm (we run one iteration of step 2 part a). By definition, this graph of one node s also (trivially) a directed acyclic graph.
\\
\textbf{Inductive Hypothesis:}\\
Assume that any directed acyclic graph G of nodes constructed by the algorithm.
\\
\textbf{Inductive Step:}\\
If a graph G of N+1 nodes is a Directed Acyclic Graph, then each subgraph of N elements of G must be a directed acyclic graph.
Because there are no cycles in a directed acyclic graph, we know that there exists at least one node n in G with an out-degree of zero (a sink).
Remove n from the graph. We are left with some graph H of N nodes. 
By our inductive hypothesis, we know that H of size N can be constructed by our algorithm.
The algorithm now adds n to the graph and its incoming edges. 
Since all other nodes have been added to the graph, the algorithm adds all the in-edges of n, and constructs G. 
By induction, if a graph is a dag, then it can be constructed by the algorithm.
\\
\\
We now prove that if a graph can be constructed by the algorithm, then the graph is a directed acyclic graph:\\
Note that in the algorithm, "the incoming edges may only come from the nodes that have been added to the graph previously."
Since we add edges incrementally, any node being added to the graph cannot have an outgoing edge that goes to a node that already exists.
Likewise, any incoming edges of a node being added to the graph must come from nodes that already exist.\\

Suppose for contradiction that a graph G can be constructed by the algorithm, and G is not a directed acyclic graph.
By definition, G must have a cycle. Suppose two nodes p and q exist in a cycle, where p has an edge to q\.
p has an outgoing edge that goes to q\.
q also has an outgoing edge that goes indirectly to some node r that has a path to p. 
But for r to have a path to p, r must have been added before p.
Since q has an incoming edge from p, it must have been added after p. 
But q has an outgoing edge to r, so it must have been added before r, and therefore, before p.
Node q is added both before and after p at the same time, which violates causality. Contradiction.\\
\\
Hence, a graph can be constructed using the algorithm if and only if it is a directed acyclic graph.



\label{pg:end-of-p2}

%Insert solution here

% Make sure that the solution here does not exceed one page here. If
% it does, use the extra space for this problem at the end.  
%
% Comment out the next line if you are NOT using the extra space
\paragraph{} \emph{Continued on Page \pageref{pg:p2-continuation}}



\newpage

\section*{Problem 3}
\textbf{Main Idea:}\\
Begin a DFS on some random node n in the graph. Remove all the children of n encountered in the depth first search. Mark N as dfsed, and keep track of the number of nodes processed.
Repeat until all nodes are processed. If only one node remains, the graph has a root node.
If more than one node remains, this means that there are seperate, directionally disconnected roots, so no root node exists.\\
Note that nodes are removed in the post phase of the DFS for runtime purposes.\\
\textbf{Pseudocode:}\\
\begin{verbatim}
def findExistsS(graph): 
    #We assume that graph's representation is a linked adjacency list
    numProcessed=0
    for node in graph:
        node.dfsed=false
        node.visited=false
    while numProcessed<graph.numNodes()
        root=graph.getSomeNotDfsed()
        root.dfsed=True
        numProcessed+=dfsModified(root,root,graph);
def dfsModified(node,root,graph): 
    #Helper function. Returns number of nodes processed.
    numNodes=1
    node.visited=True
    for child in node.children():
        if !child.visited:
            numNodes+=dfsModified(child,root)
    if (node!=root):
        graph.remove(node) #remove all children of root
    else:
        #Remove the deleted children from root's adjacency list
        graph.getAdjacencyList(root).deleteAll() 
    return numNodes
\end{verbatim}

\textbf{Proof of Correctness:}\\
Our algorithm uses the principle that the graph must have some root node s that has a path to every other node in the graph.
Observe that if some node q is reachable from node p, then any node that reaches p can also reach q. 
Since our hypothetical root node s must be able to reach both p and q, it is safe to remove q from the graph once we confirm that it is reachable from p.\\
We iteratively remove nodes connected to other nodes in the graph, since s is under the constraint that it can reach both a root node and its children. 
If there exists some s in G for which all nodes are reachable from s, then the collective set of nodes connected to s must contain all nodes in G.
Hence, if we run the algorithm, all children of s are removed, leaving s as the only node left in the graph. 
Hence, the algrithm properly detects such graphs.

\textbf{Running Time:}\\
$O(|V|+|E|)$\\
\textbf{Running Time Analysis:}\\
Each vertex is processed exactly once, where it is either (1) removed or (2) marked dfsed and never visited again.
Each edge is processed exactly once, since edges that have been traversed once by the dfs are removed from the graph along with their vertices.
Hence, this algorithm runs on $O(|V|+|E|)$\\
\label{pg:end-of-p3}

% Make sure that the solution here does not exceed one page here. If
% it does, use the extra space for this problem at the end.  
%
% Comment out the next line if you are NOT using the extra space
\paragraph{} \emph{Continued on Page \pageref{pg:p3-continuation}}




\newpage

\section*{Problem 4}

\subsection*{Part (a)}
Suppose for conradiction that a forward edge exists in a BFS tree.
By definition of forward edge, the graph G must contain an edge (p,q) that connects a node p to one of its nonchild descendents, q.
When BFS is executed on G, it must reach p before q, since BFS traverses each level of the tree in succession.
There exists an edge (p,q) from p to q, so q is pushed onto the queue when p is visited, which implies that q is a child of p.
This contradicts the definition of forward edge, which must connect a parent node to a nonchild descendent. Contradiction.
\subsection*{Part (b)}
\textbf{Main Idea:}\\
It is easy to identify tree edges in a breadth first search tree. 
They are simply the edges that are traversed in the breadth first search.
Since there are no forward edges in a breadth first search tree, all there is left is to assign non-tree edges as either backward or cross.
Observe that backward edges are non-tree edges that go to an ancestor, while cross edges are non-tree edges that don't go to an ancestor.
A constant time way to test if a node p is a descendent of node q is to see if pre(q)<pre(p)<post(q). 
(This also works for post(p). They should both fall in the interval, but to test this would be redundant.)
The algorithm, hence, is as follows:\\
Perform a DFS on the graph, labeling each node with its pre and post numbers.
Perform a BFS on the graph. 
In the BFS, for each edge (u,v), if v has been marked "seen", the edge is a tree edge. 
Otherwise, if  pre(v)<pre(u)<post(v), the edge is backward, else cross.
When a node is pushed into the queue, mark it "seen".\\
\textbf{Pseudocode:}
\begin{verbatim}
def classifyEdges(graph):
    pre,post=dfs(graph) #Get the pre/post numbers.
    for node in graph:
        node.seen=false
        node.visited=false
    queue = makeQueue(graph.root)
    while queue is not empty:
        currentNode = queue.dequeue()
        for edge in currentNode.edges:
            if edge.destination.seen:
                if pre(edge.destination)<pre(currentNode)<post(edge.destination):
                    edge.classification="back"
                else:
                    edge.classification="cross"
            else:
                edge.classification="tree"
            queue.enqueue(edge.destination)
\end{verbatim}
\textbf{Proof of Correctness:}\\
As shown above, there are no forward edges in BFS trees.
By definition of tree edge, the any edge that is traversed in the BFS is gaurunteed to be a tree edge, so our algorithm correctly identifies tree edges.
All that is left to prove is that we correctly distinguish cross and backward edges.\\
\textbf{Lemma:}If a node's pre is between another parent node's pre and post, then it is a child of the parent node.
In depth first search, a node's pre function runs before its children are traversed. A node's post function runs after its children are traversed. Hence, any node's pre and post must come between the pre and post of its parent nodes.\\
\\
Since we compare a node's pre against a potential ancestor's pre and post, we can correctly detect backward edges.
Cross edges are all that are left, so the algorithm can classify all three possible edge types.

\textbf{Running Time:}
$O(|V|+|E|)$\\
\textbf{Running Time Analysis:}\\
This algorithm is just breadth first search, which visits each vertex and edge a constant number of times.
Our additions to the algorithm, the test for ancestry and marking elements as seen, are a comparison and an assignment, respectively, which run on O(1).
Hence, the runtime is $O(|V|+|E|)$

\label{pg:end-of-p4}

% Make sure that the solution here does not exceed one page here. If
% it does, use the extra space for this problem at the end.  
%
% Comment out the next line if you are NOT using the extra space
\paragraph{} \emph{Continued on Page \pageref{pg:p4-continuation}}


\newpage

\section*{Problem 5}

Dijkstra's Algorithm will never fail on this type of graph.\\
Dijkstra's algorithm fails for generic graphs with negative numbers because it assumes that the function of each node's provisional cost to be strictly increasing.
That is, each node's provisional cost is a lower bound on its actual cost.
When negative values are introduced, this is no longer true.
In this particular example, all negative edges leave s, and s has an in-degree of 0 (no edges reenter s), so the node values are still strictly increasing after the first iteration.
Evaluate one iteration of the algorithm on s.
There is now a set of nodes with negative provisional values in the graph.
Since the values can only go up from this point, the algorithm will find the optimal path through the graph, as if the value is 0 with the result offset by some negative node's value.
Hence, Dijkstra's algorithm produces the correct result.

\label{pg:end-of-p5}

%Insert solution here


% Make sure that the solution here does not exceed one page here. If
% it does, use the extra space for this problem at the end.  
%
% Comment out the next line if you are NOT using the extra space
\paragraph{} \emph{Continued on Page \pageref{pg:p5-continuation}}


\newpage


%% Comment out the "extra spaces" completely for the problems for you
%% don't need them

\section*{Extra space for Problem 1}
\emph{Continued from Page \pageref{pg:end-of-p1}}\\

%Insert solution here


\label{pg:p1-continuation}
\subsection*{Part (c)}
\textbf{Main Idea:}\\
Add e=(u,v) to G.
Do nothing to L.
\textbf{Pseudocode:}\\
\begin{verbatim}
def addEdge(graph,L,u,v):
    graph.addEdge(u,v)
    return (graph,L)
\end{verbatim}
\textbf{Proof of Correctness:}\\
We know that pre(u)>pre(v). 
This implies that in the dfs traversal of the graph used to form L, v is visited before u.
This means that the edge (u,v) is encountered by DFS after v has been encountered. 
Node v will have already been visited, and (u,v) will not be part of the correct DFS under the tiebreaking policy.
Hence the algorithm mantains the L invariant.
\textbf{Running Time:}\\
O(1)\\
\textbf{Running Time Analysis:}\\
According to the problem spec, adding an edge to G takes O(1) time.

\subsection*{Part (d)}
\textbf{Main Idea:}\\
Add the edge to the graph.
Perform a dfs on L, labeling each vertex by preorder.
For each edge (v,u) in  the incoming edges of v, pair (v,u) with pre(u).
Find the element with the minimum preorder of pre(u), and extract its edge e.
Add u to L and connect it to the rest of the graph by e.


\textbf{
    Pseudocode:}\\
\begin{verbatim}
def addNode(v,graph,L):
    pre,post=dfs(L)
    minPre=+infinity
    minEdge=null
    for (v,u) in v.edges():
        if pre(u)<minPre:
            minEdge=(v,u)
            minPre=pre(u)
    graph.addNode(v)
    graph.addEdges(v.edges())
    L.addNode(v)
    L.addEdge(minEdge)
    return graph,L
\end{verbatim}
\textbf{Proof of Correctness:}\\
We want to add v to L with minimal or no changes to the existing tree in L.
Observe that v has an outdegree of zero; in other words, it is a leaf node.
Thus, we do not need to consider existing edges in L that are invalidated by e.
The algorithm connects v to the node in the graph with the lowest preorder. 
We now show that this produces the correct dfs.
By definition of preorder, the node with the lowest preorder with an edge to v occurs earlier in the DFS than any other node with an edge to v.
Hence, in the DFS traversal of the graph, this lowest preorder node "sees" v first, and its edge to v is traversed.
Node v is then marked visited and never visited again, so no other edge to v is traversed. 
Hence, v's only edge in L is the edge from the lowest preorder node, and the algorithm produces the correct L.


\textbf{Running Time:}\\
$O(|V|)$\\
\textbf{Running Time Analysis:}\\
The initial DFS takes $O(|V|)$ time.
We then iterate through the edges of v to find the min. 
Since there are only $|V|$ nodes, there is a maximum of $|V|$ items to iterate through.
Adding each edge to the graph takes $O(1)$ time as per the problem description. This $|V|$ times is $O(|V|)$
Adding a single edge and a single vertex to L is $O(1)$.
$|V|+|V|+|V|+|V|+1=4V+1=O(|V|)$

\subsection*{Part (e)}
The datastructure is an adjacency list.

\newpage
%%Comment out the above three lines if you are not using extra space
%%for this problem.


\section*{Extra space for Problem 2}
\emph{Continued from Page \pageref{pg:end-of-p2}}\\

%Insert solution here

\label{pg:p2-continuation}
\newpage
%%Comment out the above three lines if you are not using extra space
%%for this problem.


\section*{Extra space for Problem 3}
\emph{Continued from Page \pageref{pg:end-of-p3}}\\

%Insert solution here

\label{pg:p3-continuation}
\newpage
%%Comment out the above three lines if you are not using extra space
%%for this problem.



\section*{Extra space for Problem 4}
\emph{Continued from Page \pageref{pg:end-of-p4}}\\

%Insert solution here

\label{pg:p4-continuation}
\newpage
%%Comment out the above three lines if you are not using extra space
%%for this problem.



\section*{Extra space for Problem 5}
\emph{Continued from Page \pageref{pg:end-of-p5}}\\

%Insert solution here


\label{pg:p5-continuation}
\newpage
%%Comment out the above three lines if you are not using extra space
%%for this problem.



\end{document}
