/*
 *
 */
#include <string>
#include <vector>
#include <iostream>
#include <cstdlib>
using namespace std;



//Represents (amount) quantity of (name)s
struct Item{//Struct representing an n quantity of an item
	string name;
	int amount;
};
vector<Item> sort(vector<Item> v, string mode);

//Represents an inventory.
class Inventory{
	public:
		Inventory();
		void Update (string item, int amount);
		void ListByName (void);
		void ListByQuantity (void);
	private:
		vector<Item> myList;
};

//Constructs an inventory. Initializes the internal list structure.
Inventory::Inventory(){
	myList=vector<Item>(0);//Construct the inventory.
}

//Adds (amount) (item)s
void Inventory::Update (string item, int amount){
	for (int i = 0; i < myList.size(); i++){//Check if item is already in the list.
		if (myList.at(i).name==item){
			myList.at(i).amount+=amount;
			return;
		}
	}
	Item it;//If not, add it.
	it.name=item;
	it.amount=amount;
	myList.push_back(it);
}

//Lists items in alphabetical order
void Inventory::ListByName (){
	vector<Item> out = sort(myList,"alpha");//Sort list by alphabetical order, and print.
	for (int i = 0; i < out.size(); i++){
		cout << out[i].name << ": " << out[i].amount << endl;
	}
}

//Lists items ordered by quantity
void Inventory::ListByQuantity (){
	vector<Item> out = sort(myList,"numeric");//Sort list by numerical order, and print.
	for (int i = 0; i < out.size(); i++){
		cout << out[i].name << ": " << out[i].amount << endl;
	}
}

//Sorts items by quantity
vector<Item> quicksort_amt(vector<Item> v, int low, int high){//Quicksort algorithm
	int i = low;
	int j = high;
	int pivot = v[(high+low)/2].amount;//Find the midpoint of list
	while (i <= j){
		while (v[i].amount<pivot){//Find each item less than pivot
			i++;
		}
		while (v[j].amount>pivot){//Find each item greater than pivot
			j--;
		}
		if (i<=j){//When an item less than and greater than pivot is found, switch them.
			swap(v[i],v[j]);
			i++;
			j--;
		}
	}
	//Recursively sort each generated list.
	if (low < j){
		v=quicksort_amt(v,low,j);
	}
	if (i < high){
		v=quicksort_amt(v,i,high);
	}
	return v;
}

//Sorts items alphabetically
vector<Item> quicksort_item(vector<Item> v, int low, int high){//Quicksort algorithm
	for (int i = 0; i < v.size(); i++){
		if (i == low){
		}
		if (i == high){
		}
	}

	int i = low;
	int j = high;
	string pivot = v[(high+low)/2].name;
	while (i <= j){
		while (v[i].name<pivot){//Find each item less than pivot
			i++;
		}
		while (v[j].name>pivot){//Find each item greater than pivot
			j--;
		}
		if (i<=j){//When an item less than and greater than pivot is found, switch them.
			swap(v[i],v[j]);
			i++;
			j--;
		}
	}
	//Recursively sort each generated list.
	if (low < j){
		v=quicksort_item(v,low,j);
	}
	if (i < high){
		v=quicksort_item(v,i,high);
	}
	return v;
}

//Sorts items based on mode specified by the presence of hte string 'alpha'
vector<Item> sort(vector<Item> v, string mode){//Sort function. Chooses the correct sorting algorithm based on mode.
	if (mode == "alpha"){
		return quicksort_item(v,0,v.size()-1);
	}else{
		return quicksort_amt(v,0,v.size()-1);
	}
}


//Swaps two references
void swap(Item& a, Item&b){//Switches items a and b. Helper to quicksort.
	Item temp = b;
	b=a;
	a=temp;
}


//Tests
int main(){
	Inventory i;
	i.Update("cake",4);
	i.Update("flux capacitors",7);
	i.Update("circles",1);
	cout << endl << "Listing by Name."<<endl;
	i.ListByName();
	cout << endl << "Listing by Quantity."<<endl;
	i.ListByQuantity();
}
