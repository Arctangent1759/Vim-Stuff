/* ListSorts.java */

import list.*;

public class ListSorts {

	private final static int SORTSIZE = 1000000;

	/**
	 *	makeQueueOfQueues() makes a queue of queues, each containing one item
	 *	of q.	Upon completion of this method, q is empty.
	 *	@param q is a LinkedQueue of objects.
	 *	@return a LinkedQueue containing LinkedQueue objects, each of which
	 *		contains one object from q.
	 **/
	public static LinkedQueue makeQueueOfQueues(LinkedQueue q) {
		LinkedQueue out = new LinkedQueue();
		LinkedQueue curr;
		while (!q.isEmpty()){
			curr = new LinkedQueue();
			try{
			curr.enqueue(q.dequeue());
			}catch(QueueEmptyException e){
				System.out.println("Something that should not have happened happened. 24.");
				System.exit(1);
			}
			out.enqueue(curr);
		}
		return out;
	}

	/**
	 *	mergeSortedQueues() merges two sorted queues into a third.	On completion
	 *	of this method, q1 and q2 are empty, and their items have been merged
	 *	into the returned queue.
	 *	@param q1 is LinkedQueue of Comparable objects, sorted from smallest 
	 *		to largest.
	 *	@param q2 is LinkedQueue of Comparable objects, sorted from smallest 
	 *		to largest.
	 *	@return a LinkedQueue containing all the Comparable objects from q1 
	 *	 and q2 (and nothing else), sorted from smallest to largest.
	 **/
	public static LinkedQueue mergeSortedQueues(LinkedQueue q1, LinkedQueue q2) {
		// Replace the following line with your solution.
		LinkedQueue out = new LinkedQueue();
		while (!q1.isEmpty() && !q2.isEmpty()){
			try{
				switch (((Comparable)q1.front()).compareTo((Comparable)(q2.front()))){
					case -1:
						out.enqueue(q1.dequeue());
						break;
					case 1:
						out.enqueue(q2.dequeue());
						break;
					case 0:
						out.enqueue(q2.dequeue());
						out.enqueue(q1.dequeue());
						break;
					default:
						System.out.println("Something that should not have happened happened. 60.");
						System.exit(1);
				}
			}catch(QueueEmptyException e){
				System.out.println("Something that should not have happened happened. 64.");
				System.exit(1);
			}
		}
		if (!q1.isEmpty()){out.append(q1);}
		if (!q2.isEmpty()){out.append(q2);}
		return out;
	}

	/**
	 *	partition() partitions qIn using the pivot item.	On completion of
	 *	this method, qIn is empty, and its items have been moved to qSmall,
	 *	qEquals, and qLarge, according to their relationship to the pivot.
	 *	@param qIn is a LinkedQueue of Comparable objects.
	 *	@param pivot is a Comparable item used for partitioning.
	 *	@param qSmall is a LinkedQueue, in which all items less than pivot
	 *		will be enqueued.
	 *	@param qEquals is a LinkedQueue, in which all items equal to the pivot
	 *		will be enqueued.
	 *	@param qLarge is a LinkedQueue, in which all items greater than pivot
	 *		will be enqueued.	
	 **/	 
	public static void partition(LinkedQueue qIn, Comparable pivot, 
															 LinkedQueue qSmall, LinkedQueue qEquals, 
															 LinkedQueue qLarge) {
		try{
		while (!qIn.isEmpty()){
			switch (((Comparable)qIn.front()).compareTo(pivot)){
				case 0:
					qEquals.enqueue(qIn.dequeue());
					break;
				case 1:
					qLarge.enqueue(qIn.dequeue());
					break;
				case -1:
					qSmall.enqueue(qIn.dequeue());
					break;
				default:
			}
		}
		}catch(QueueEmptyException e){
			System.out.println("Something that should not have happened happened. 102.");
			System.exit(1);
		}
	}

	/**
	 *	mergeSort() sorts q from smallest to largest using mergesort.
	 *	@param q is a LinkedQueue of Comparable objects.
	 **/
	public static void mergeSort(LinkedQueue q) {
		if (q.isEmpty()){
			return;
		}
		LinkedQueue qq = makeQueueOfQueues(q);
		while (qq.size()>1){
			try{
				qq.enqueue(mergeSortedQueues((LinkedQueue)qq.dequeue(),(LinkedQueue)qq.dequeue()));
			}catch(QueueEmptyException e){
				System.out.println("Something that should not have happened happened. 102.");
				System.exit(1);
			}
		}
		try{
			q.append((LinkedQueue)qq.dequeue());
		}catch(QueueEmptyException e){
			System.out.println("Something that should not have happened happened. 102.");
			System.exit(1);
		}
	}

	/**
	 *	quickSort() sorts q from smallest to largest using quicksort.
	 *	@param q is a LinkedQueue of Comparable objects.
	 **/
	public static void quickSort(LinkedQueue q) {
		if (q.isEmpty()){
			return;
		}
		Comparable pivot = (Comparable)q.nth((int)Math.ceil(Math.random()*q.size()));
		LinkedQueue left = new LinkedQueue();
		LinkedQueue right = new LinkedQueue();
		LinkedQueue middle = new LinkedQueue();
		partition(q,pivot,left,middle,right);
		quickSort(left);
		quickSort(right);
		q.append(left);
		q.append(middle);
		q.append(right);
	}

	/**
	 *	makeRandom() builds a LinkedQueue of the indicated size containing
	 *	Integer items.	The items are randomly chosen between 0 and size - 1.
	 *	@param size is the size of the resulting LinkedQueue.
	 **/
	public static LinkedQueue makeRandom(int size) {
		LinkedQueue q = new LinkedQueue();
		for (int i = 0; i < size; i++) {
			q.enqueue(new Integer((int) (size * Math.random())));
		}
		return q;
	}

	/**
	 *	main() performs some tests on mergesort and quicksort.	Feel free to add
	 *	more tests of your own to make sure your algorithms works on boundary
	 *	cases.	Your test code will not be graded.
	 **/
	public static void main(String [] args) {

		LinkedQueue q = makeRandom(10);
		System.out.println(q.toString());
		mergeSort(q);
		System.out.println(q.toString());

		q = makeRandom(10);
		System.out.println(q.toString());
		quickSort(q);
		System.out.println(q.toString());

		/*
		Timer stopWatch = new Timer();
		q = makeRandom(SORTSIZE);
		stopWatch.start();
		mergeSort(q);
		stopWatch.stop();
		System.out.println("Mergesort time, " + SORTSIZE + " Integers:	" +
											 stopWatch.elapsed() + " msec.");

		stopWatch.reset();
		q = makeRandom(SORTSIZE);
		stopWatch.start();
		quickSort(q);
		stopWatch.stop();
		System.out.println("Quicksort time, " + SORTSIZE + " Integers:	" +
											 stopWatch.elapsed() + " msec.");
		*/
		
		//Testing stability
		Thing a = new Thing(-4,"a");
		Thing b = new Thing(0,"b");
		Thing c = new Thing(6,"c");
		Thing d = new Thing(2,"d");
		Thing e = new Thing(0,"e");
		q = new LinkedQueue();
		q.enqueue(a);
		q.enqueue(b);
		q.enqueue(c);
		q.enqueue(d);
		q.enqueue(e);
		mergeSort(q);
		System.out.println(q);

	}
	private static boolean isSorted(LinkedQueue q){
		if (q.isEmpty()){
			return true;
		}
		try{
			Comparable c=(Comparable)q.dequeue();
			while (!q.isEmpty()){
				if (c.compareTo(q.front())==1){
					return false;
				}
				c=(Comparable)q.dequeue();
			}
		}catch(QueueEmptyException e){
			System.exit(1);
		}
		return true;
	}

}
class Thing implements Comparable{
	int x;
	String name;
	public Thing(int x,String name){
		this.x=x;
		this.name=name;
	}
	public int compareTo(Object t){
		if (((Thing)t).x==this.x) {return 0;}
		return this.x>((Thing)t).x?1:-1;
	}
	public String toString(){
		return name;
	}

}
