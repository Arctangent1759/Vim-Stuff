#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "memory.h"


/* Pointer to simulator memory */
uint8_t *mem;
/* Create variable to keep track of heap status here 
   You may change this to use your own implementation. */


/******************************
 * Heap Status Data Structure *
 ******************************/
/**
 * 
 * Struct containing a single memListNode.
 * Invariant: The size of a valid node will never be zero.
 * The only zero-size node will be the sentinel of the circularly linked list.
 *
 */
typedef struct memListNode{
  struct memListNode *next; //Doubly linked list next pointer
  struct memListNode *prev; //Doubly linked list prev pointer
  unsigned int size;        //Size of memory block
  int index;                //Position of memory block relative to zero
  int allocated;            //Boolean determining whether block has been allocated
} memlist_t;
memlist_t *heap_status;

/**
 *
 * Creates a MemListNode representing a block of size size and index index.
 *
 */
memlist_t *makeMemListNode(int size, int index){
  memlist_t *out = (memlist_t*)malloc(sizeof(memlist_t));
  if (!out){
	/*Memory allocation failed!*/
	printf("Memory allocation failed.\n");
	exit(1);
  }
  out->next=out;
  out->prev=out;
  out->size=size;
  out->index=index;
  out->allocated=0;
  return out;
}

/**
 *
 * Returns whether a given node is the root.
 *
 */
int isRoot(memlist_t *node){
  return node->size==0;
}

/**
 *
 * Removes and frees a memListNode
 *
 */
void removeMemListNode(memlist_t* child){
  if (isRoot(child)){
	printf("Attempted to delete root node node.");
	exit(1);
  }
  child->prev->next=child->next;
  child->next->prev=child->prev;
  free(child);
}

/**
 *
 * Appends a memListNode b after memLstNode a.
 *
 */
void appendMemListNode(memlist_t *a, memlist_t *b){
  b->next=a->next;
  b->prev=a;
  a->next->prev=b;
  a->next=b;
}
/**
 * Merges memListNode a into memListNode b
 *
 */
void mergeMemListNode(memlist_t *a, memlist_t *b){
  a->size+=b->size;
  removeMemListNode(b);
}

/**
 *
 * Allocates allocSize bits of memListNode n.
 * If n is smaller than allocSize, throw an error and exit.
 * If n is larger than allocSize, split the node and append 
 * the two resulting nodes together. Allocate one of the nodes.
 *
 */
int allocMemListNode(memlist_t* n,int allocSize){
  if (allocSize>n->size || n->allocated){
	/* allocSize too big */
	printf("Attempted to allocate memory of an undersized or occupied node.\n");
	exit(1);
  }
  n->allocated = 1;
  if (n->size==allocSize){
	/* Perfect fit case */
	return n->index;
  }
  
  /* Split node */
  appendMemListNode(n,makeMemListNode(n->size-allocSize,n->index+allocSize));
  n->size=allocSize;
  return n->index;
}

/**
 *
 * 	Frees space in the heap by deallocating a MemListNode.
 * 	Merges a node with its free neighbors if present.
 *
 */
void deallocMemListNode(memlist_t *n){
  n->allocated=0;
  if (!(isRoot(n->next) || n->next->allocated)){
	mergeMemListNode(n,n->next);
  }
  if (!(isRoot(n->prev) || n->prev->allocated)){
	mergeMemListNode(n->prev,n);
  }
}


//Next pointer for next fit malloc
memlist_t *nextFitPtr;

/**
 * 
 * Initializes the heap. Used in place of init_heap_status().
 * 
 */
memlist_t *initialize_heap(){
  memlist_t * out = makeMemListNode(0,0); //Create sentinel node (invalid because size==0)
  appendMemListNode(out,makeMemListNode(HEAP_TOP-HEAP_BOTTOM,HEAP_BOTTOM)); //Appends a node representing the rest of the memory to the list.
  nextFitPtr=out->next;
  return out;
}




/* Called by program loader to initialize memory. */
uint8_t* init_mem() {
  assert (mem == NULL);
  mem = (uint8_t*) calloc(MEM_SIZE, sizeof(uint8_t)); // allocate zeroed memory
  if (mem==NULL) fprintf(stderr, "%s: Allocation Failed\n", __FUNCTION__);

  //you may change the following line if using your own implementation to maintain the heap
  heap_status = initialize_heap();
  return (uint8_t*) mem;
}

/* Called in init_mem() to initialize your implementation of
   how you keep track of heap allocation status.*/
uint8_t* init_heap_status(){
  //Do nothing.
  return (uint8_t*) 0;
}

/* Returns 1 if memory access is ok, otherwise returns 0. 
   The parameter write_permission is the macro READ if this is
   a read request, and WRITE if it is a write request. See memory.h. */

int access_ok(uint32_t mipsaddr, mem_unit_t size, uint8_t write_permission) {
  // Check address alignment
  if ((size == SIZE_WORD && (mipsaddr%4!=0)) || (size == SIZE_HALF_WORD && (mipsaddr%2!=0))){
	return 0;
  }
  if (mipsaddr >=0 && mipsaddr + size < CODE_BOTTOM){
	//Attempting to access any memory address in the reserved section: [1,CODE_BOTTOM) 
	return 0;
  }else if (mipsaddr >= CODE_BOTTOM && mipsaddr + size < CODE_TOP){
	//Attempting to write into a read-only memory address. For this project, the only read-only section is the code section: [CODE_BOTTOM,CODE_TOP). 
	return write_permission==READ;
  }else if (mipsaddr >= HEAP_BOTTOM && mipsaddr + size < HEAP_TOP){
	//Attempting to access unallocated memory in the heap: [HEAP_BOTTOM,HEAP_TOP). Memory in the heap must be allocated using first_fit_malloc() or next_fit_malloc() before it can be accessed.
	memlist_t *ptr;
	for (ptr = heap_status->next;!isRoot(ptr);ptr=ptr->next){
	  //Iterate through the heap until the node is found. Return whether the node is allocated.
	  if (ptr->index<=mipsaddr && mipsaddr + size-1<ptr->index + ptr->size){
		return ptr->allocated;
	  }
	}
	//If the address is not a node in the heap, then it's not a valid access.
	return 0;
  }else if (mipsaddr >= MEM_SIZE || mipsaddr + size >= MEM_SIZE){
	// Attempting to access a memory address that is greater than or equal to MEM_SIZE.
	return 0;
  }
  //Address is in stack.
  return 1;
}

/* Writes size bytes of value into mips memory at mipsaddr */
void store_mem(uint32_t mipsaddr, mem_unit_t size, uint32_t value) {
  if (!access_ok(mipsaddr, size, WRITE)) {
	fprintf(stderr, "%s: bad write=%08x\n", __FUNCTION__, mipsaddr);
	exit(-1);
  }
  if (size==SIZE_BYTE){ //Write byte
	mem[mipsaddr]=value;
  }else if (size==SIZE_HALF_WORD){ //Write halfword. Stores data across two bytes
	mem[mipsaddr]=value & 0xff;
	mem[mipsaddr+1]=value >> 8 & 0xff;
  }else if (size==SIZE_WORD){ //Write word. Stores data across four bytes
	mem[mipsaddr]=value & 0xff;
	mem[mipsaddr+1]=value >> 8 & 0xff;
	mem[mipsaddr+2]=value >> 16 & 0xff;
	mem[mipsaddr+3]=value >> 24 & 0xff;
  }else{//Not a word, halfword, or byte
	printf("Invalid size in store_mem");
	exit(1);
  }
}

/* Returns zero-extended value from mips memory */
uint32_t load_mem(uint32_t mipsaddr, mem_unit_t size) {
  if (!access_ok(mipsaddr, size, READ)) {
	fprintf(stderr, "%s: bad read=%08x\n", __FUNCTION__, mipsaddr);
	exit(-1);
  }
  if (size==SIZE_BYTE){
	return mem[mipsaddr];
  }else if (size==SIZE_HALF_WORD){//Splice together 2 bits
	return mem[mipsaddr]+(mem[mipsaddr+1]<<8);
  }else if (size==SIZE_WORD){
	return mem[mipsaddr]+(mem[mipsaddr+1]<<8)+(mem[mipsaddr+2]<<16)+(mem[mipsaddr+3]<<24);//Splice together 4 bits
  }else{
	printf("Invalid size in load_mem");
	exit(1);
  }
}

/*Uses the first fit algorithm to allocate a block of size bytes 
  in the heap. Returns the address of the start of the block 
  if allocation is successful, returns 0 on failure.*/
uint32_t first_fit_malloc(uint32_t size){
  memlist_t *ptr;
  for (ptr = heap_status->next;ptr->size;ptr=ptr->next){//Iterate through the memlist until a sufficiently large, unallocated node is found.
	if (ptr->size >= size && !ptr->allocated){
	  return allocMemListNode(ptr,size); //Allocate that node.
	}
  }
  return 0; //If the list end is reached, then we have insufficient memory.
}


/*Free the allocated block of memory in the heap beginning at
  mipsaddr. In order to successfully free a block, mipsaddr must 
  be the beginning of a block that was allocated on the heap. 
  If block_free() is called on an unallocated memory address or an address
  that is not the beginning of a block, bad_free() should be called.
  */

void block_free(uint32_t mipsaddr){
  memlist_t *ptr;
  for (ptr = heap_status->next;ptr->size;ptr=ptr->next){
	if (ptr->index==mipsaddr){
	  if (!ptr->allocated){//Cannot deallocate a block that is not allocated
		bad_free(mipsaddr);
	  }

	  if (nextFitPtr==ptr->next){//Make next fit pointer fall back if it is right after the pointer being freed.
		nextFitPtr=nextFitPtr->prev;
		//Falls through to next case if it is the case that that block in turn has a free block behind it.
	  }

	  if (nextFitPtr==ptr && !ptr->prev->allocated){//If the next fit pointer is the block being freed, make it fall back.
		nextFitPtr=nextFitPtr->prev;
	  }
	  deallocMemListNode(ptr);//Deallocates the block being freed, merging it with any adjacent free blocks.
	  return;
	}
  }
  bad_free(mipsaddr); //The address to be freed is not the beginnning of the block. Cannot deallocate.
}



/*Implementation of this function is optional but may be useful for debugging.
  This function will not be graded and is for your benefit only. To call this 
  function in MIPS, use syscall with $v0=64.*/

void print_heap_status(){
  printf("\n\n----------\n");
  memlist_t *ptr;
  for (ptr = heap_status->next;ptr->size;ptr=ptr->next){
	printf("ptr: %p --> {\n\tallocated:%d\n\tindex:%d\n\tsize:%d}\n",ptr,ptr->allocated,ptr->index,ptr->size);
  }
  printf("----------\n\n");
}

/*Called when trying to free an invalid address. Do NOT
  change this function.*/
void bad_free(uint32_t mipsaddr){
  fprintf(stderr, "%s: bad free=%08x\n", __FUNCTION__, mipsaddr);
  exit(-1);
}


/**Extra Credit**/
/*Wait until completing the rest of the project to work on this part; it
  requires significantly more work than first_fit_malloc().
  You may need to declare new variables and/or modify functions you 
  have already completed.*/


uint32_t next_fit_malloc(uint32_t size){
  memlist_t *startNode = nextFitPtr;//Record where the search for a free block started.
  do{
	if (nextFitPtr->size >= size && !nextFitPtr->allocated){
	  uint32_t out = allocMemListNode(nextFitPtr,size);
	  nextFitPtr=nextFitPtr->next;
	  if (isRoot(nextFitPtr)){
		/*Advance twice for sentinel*/
		nextFitPtr=nextFitPtr->next;
	  }
	  return out;
	}
	nextFitPtr=nextFitPtr->next;
	if (isRoot(nextFitPtr)){
	  /*Advance twice for sentinel*/
	  nextFitPtr=nextFitPtr->next;
	}
  }while(nextFitPtr!=startNode);
  return 0;//We have made a full cycle around the list. There is insufficient space for the block.

}
