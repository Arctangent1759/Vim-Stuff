==========================================
Course Introduction, Number Representation
==========================================

What is cs61c about?
====================
  It is about \_hardware-software interface\_
	-What does the programmer need to know to achieve the highest performance?
  Use low-level programming languages (closer to the underlying hardware)
	-Work with lower-level hardware features

  Leverage \*parallelism\* and achieve high performance.

  Why care?
  ---------
	Personal Mobile Devices
	Cloud computing

The Six Great Ideas in Computer Architecture
============================================
  1. Levels of Representation/Interpretation/Abstraction
	-ANYTHING can be represented as a number:
	  words, colors, data, logic, etc
  2. Technology Trends
	-Moore's law: Transistor count per chip doubles every 2 years
  3. Memory Hierarchy
	-Minimize the need to access disk or other slow memory
  4. Parallelism
	-Split processes into threads with fork() and join with join()
  5. Performance Measurement and Improvement
	-Allows direct comparisons  of architectures and quantification of improvements
  6. Redundancy => Dependency
	-Applies to everything from data centers to memory
	-Increasing transistor density reduces the cost of redundancy.

  R T M P P R

Number Representation
=====================
  Key Terms:
	digit (d): a n-digit number is a sequence of d_(n-1) d_(n-2) ... d_1 d_0
	base (b): In base B, each digit is one of B possible symbols.
	Most Significant Bit (MSB): Leftmost bit
	Least Significant Bit (MSB): Rightmost bit


  Numbers are an abstract concept!

  Recognize that these are \_arbitrary\_ symbols

  Computers store everything as a strings of 1s and 0s (even 0 and 1 are abstractions; they are just voltages)

  Integers
  --------
	Commonly used number bases:

	  Decimal (base 10)
	  Binary (base 2)
	  Hexadecimal (base 16)

	  TODO: Memorize Binary-Decimal-Hex chart!
	
	Examples:
	  9472 = 9000 + 400 + 70 + 2
		   = 9*1000 + 4*100 + 7*10 + 2*1
		   = 9*10^3 + 4*10^2 + 7*10^1 + 2*10^0

	  9472 = 2*16^3 + 5*16^2 + 0*16^1 + 6*16^0
		   = 2506_(hex)
	
	n digits in base B can represent B^n represent at most B^n things
	A \*nibble\* is 4 bits.

	Here we are using binary bit patterns to represent numbers.

	Strictly speaking they are called numerals an have no meaning how you interpret them
	  Is CAB a word (taxi)  or a number?
	
	Numbers actually have \infinity digits, but hardware can only store a finite number of them (fixed)
	  -Usually ignore leading zeros

	Unsigned Integers:
	  Represent only non-negative (unsigned) integers:
	  0000=0
	  0001=1
	  ...
	  0110=6
	  1000=8
	  1111=15

	Signed Integers:
	  n bits represent 2^n different things
	  Ideally, we want the range split evenly between + and -
	  How do we want to encode zero?
	  
	  Sign and Magnitude:

		MSB gives sign, rest treated as unsigned

		Zero: 000 and 100
		Most negative number: -(2^(n-1)-1)
		Most positive number: (2^(n-1)-1)
		Increment: Increases positive numbers, decreases negative numbers (BAD!)

		Problem: Increment doesn't work!

	  Biased Notation:
		Like unsigned, but "shifted" so zero is in the middle (0b0 is the most negative number):
		0000=-7
		0001=-7
		...
		0110=-1
		0111=+0
		1000=+1
		...
		1110=+7
		1111=+8

		Zero: 0111
		Most negative number: -(2^(n-1)-1)
		Most positive number: (2^(n-1)-1)
		Increment: Works!

		Problem: Zero isn't 0!

	  One's Complement:
		New negation procedure -- complement all the bits.

		0000=+0
		0001=+1
		...
		0110=+6
		0111=+7
		1000=-7
		1001=-6
		...
		1110=-1
		1000=-0

		Zero: 0000 and 1000
		Most negative number: -(2^(n-1)-1)
		Most positive number: (2^(n-1)-1)
		Increment: Works!
		
		Problem: 2 zeros

	  Two's Complement:
		Like One's complement, but shift negative numbers by 1
		0000=+0
		0001=+1
		...
		0110=+6
		0111=+7
		1000=-8
		1001=-7
		...
		1110=-2
		1000=-1

		Zero: 0000
		Most negative number: -(2^(n-1)) (One more!)
		Most positive number: (2^(n-1)-1)
		Increment: Works!

	  Two's Complement Summary
	  ------------------------
		Used by all modern hardware
		Rougly even split between positive and negative
		One more negative number because positive has 0
		Can still use MSB as sign bit
		To negate, flip bits and add one
		Example: +7 = 0b00000111, -7 = 0b11111001

	  Overflow
	  --------
		When the result of an arithmetic operation can't be represented by hardware bits, and is therefore mathematically incorrect.

		Examples: 
		  Unsigned: 0b1...1 + 1 = 0b0...
		  Signed: 0b1...1 + 1 = 0b0...0 = -2^(n-1)

		Sign extension
		  Want to represent the same number using more bits than before.
		  Easy for postive numbers, more complicated for negative numbers.
		  Sign and magnitude: Add 0s after the sign bit
		  One's Complement: Copy MSB
		  Two's Complement: Copy MSB
