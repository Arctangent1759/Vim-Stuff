.text

# _start is the entry point into any program.
.global _start
.ent    _start 
_start:

#
#  The header ends here, and code goes below
#
	# disassembly test
	ori $30, $0, 0

	# test #1: sll
	ori $30, $0, 1
	ori $8, $0, 0x1a6f
	ori $9, $0, 0x34de
	sll $10, $8, 1
	bne $10, $9, fail

	# test #2: srl
	ori $30, $0, 2
	ori $8, $0, 0x34de
	ori $9, $0, 0x1a6f
	srl $10, $8, 1
	bne $10, $9, fail

	# test #3: sll and srl
	ori $30, $0, 3
	ori $8, $0, 0x1
	sll $9, $8, 17
	srl $10, $9, 17
	bne $10, $8, fail

	# test #4: sra
	ori $30, $0, 4
	lui $8, 0xF6FA
	ori $8, $8, 0x24CE
	sra $9, $8, 2
	lui $10, 0xFDBE
	ori $10, $10, 0x8933
	bne $10, $9, fail
	# vs. srl
	srl $11, $8, 2
	lui $12, 0x3DBE
	ori $12, $12, 0x8933
	bne $11, $12, fail

	# test #5: jr

	ori $30, $0, 5
	ori $8, $0, 0x107c
	jr $8
	j fail

	# test #6: jalr

	ori $30, $0, 6
	ori $8, $0, 0x1088
	li $31, 0x108c
	jr $31
	jalr $8
	j 0x1098
	j fail

	# test #7: add

	ori $30, $0, 7
	lui $8, 0x7fff
	ori $8, $8, 0xffff # 8 is largest positive number
	ori $11, $0, 0x1 
	#add $10, $8, $11 # uncomment causes arithmetic overflow
	lui $9, 0x8000 # 9 is largest negative number
	lui $12, 0xffff
	ori $12, $12, 0xffff
	add $10, $9, $12 # uncomment causes arithmetic overflow
	add $13, $8, $9
	bne $13, $12, fail # adding largest negative and largest pos should be -1

	# test #8: addu
	ori $30, $0, 8
	ori $8, $0, 0x0abc
	ori $10, $0, 0x1000
	addu $12, $10, $8
	ori $11, $0, 0x1abc
	bne $12, $11, fail

	# test #9: xor
	ori $30, $0, 9
	ori $8, $0, 0xf0f0
	ori $9, $0, 0x00ff
	ori $10, $0, 0xf00f
	xor $11, $8, $9
	bne $10, $11, fail

	# test #10: slt
	ori $30, $0, 10
	lui $8, 0xffff
	ori $8, $8, 0xffff
	ori $9, $0, 0xbeef
	slt $10, $9, $8
	bne $10, $0, fail

	# test #11: jal
	ori $30, $0, 11
	ori $8, $0, 0
	ori $9, $0, 0
label:
	beq $8, $0, 8
	ori $9, $0, 1
	jr $31
	ori $8, $0, 1
	jal label
	beq $9, $0, fail

	# test #12: beq
	ori $30, $0, 12
	ori $8, $0, 1
	beq $8, $0, -900

	# test #13: bne
	ori $30, $0, 13
	ori $8, $0, 0
	bne $8, $0, -900 # mainly assuming bne and beq work, testing disassmblement

	# test #14: addiu
	ori $30, $0, 14
	ori $8, $0, 0x2a
	addiu $9, $8, -42
	bne $9, $0, fail

	# test #15: xori
	ori $30, $0, 15
	ori $8, $0, 0xf0f0
	xori $9, $8, 0xff
	ori $10, $0, 0xf00f
	bne $9, $10, fail

	# test #16: lui
	ori $30, $0, 16
	ori $8, $0, 0xf0f0
	lui $8, 0x0
	bne $8, $0, fail

	# test #17: lb
	ori $30, $0, 17
	la $8, RLS
	addiu $8, $8, 8
	lb $9, -8($8)
	bne $9, $0, fail

	# test #18: sb/lbu
	ori $30, $0, 18
	addiu $8, $8, 28672
	addiu $10, $0, 0xff
	sb $10, -8($8)
	lbu $11, -8($8)
	addiu $14, $0, 255
	bne $14, $10, fail
	bne $10, $11, fail # lbu should generate same thing put in
	lb $12, -8($8)
	beq $11, $12, fail # lb has to sign extend
	addiu $13, $0, -1
	bne $13, $12, fail


	# test #19: sw/lw
	ori $30, $0, 19
	addiu $10, $0, 0xbeef
	sw $10, -8($8)
	lw $11, -8($8)
	bne $11, $10, fail


	
pass:
        la $a0, passstring
        li $v0, 4
        syscall
        b done

fail:
        ori $a0, $0, %lo(fail1string)
        ori $v0, $0, 4
        syscall

        ori  $a0, $30, 0
        ori  $v0, $0, 1
        syscall

        ori $a0, $0, %lo(fail2string)
        ori $v0, $0, 4
        syscall

done:
        ori $v0, $zero, 10
        syscall

.end _start

.data
passstring:     .asciiz "Kevin's Test Suite Passed!!!\n"
fail1string:    .asciiz "test #"
fail2string:    .asciiz " failed!\n"
RLS: .word 0x1200
